# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_GeneralConferenceTalk.ipynb.

# %% auto 0
__all__ = ['GeneralConferenceTalk']

# %% ../nbs/00_GeneralConferenceTalk.ipynb 3
from bs4 import BeautifulSoup
import requests
import re

class GeneralConferenceTalk:
    """Represents a talk from the Church of Jesus Christ of Latter-day Saints' General Conference."""
    def __init__(self, 
                 url:str, # The URL of the talk's transcript.
                 title:bool=True, # Flag to include the title or not.
                 author:bool=True, # Flag to include the author's name or not.
                 calling:bool=True): # Flag to include the author's calling or not.
        self.url = url 
        self.title = title 
        self.author = author 
        self.calling = calling 
        self.text = self._extract_text() 
        self.metadata = self._extract_metadata()

    def _extract_text(self) -> str:
        """Extracts the text content from the talk's transcript."""
        response = requests.get(self.url)
        soup = BeautifulSoup(response.content, 'html.parser')

        # Find all paragraphs with IDs starting with "p"
        title_header = soup.find_all('h1')
        author1 = soup.find_all('p', id='author1')
        author2 = soup.find_all('p', id='author2')
        paragraphs = soup.find_all('p', id=lambda x: x and x.startswith('p'))

        # Create a list to store the extracted paragraphs
        text_paragraphs = []

        # Extract text from title header if title argument is True
        if self.title and title_header:
            text_title_header = title_header[0].get_text().strip()
            text_paragraphs.append(text_title_header)

        # Extract text from author1 and author2 if author and calling arguments are True
        if self.author and author1:
            text_author1 = author1[0].get_text().strip()
            text_paragraphs.append(text_author1)

        if self.calling and author2:
            text_author2 = author2[0].get_text().strip()
            text_paragraphs.append(text_author2)

        # Extract text from each paragraph
        for paragraph in paragraphs:
            text_paragraphs.append(paragraph.get_text())

        # Concatenate all paragraphs into a single text
        result_text_paragraphs = []
        if self.title:
            if self.author and not self.calling:
                result_text_paragraphs.append(text_paragraphs[0:2])
                result_text_paragraphs.append(text_paragraphs[3:])
            elif not self.author and self.calling:
                result_text_paragraphs.append(text_paragraphs[0:1])
                result_text_paragraphs.append(text_paragraphs[2:])
            elif not self.author and not self.calling:
                result_text_paragraphs.append(text_paragraphs[0:1])
                result_text_paragraphs.append(text_paragraphs[3:])
            else:
                result_text_paragraphs.append(text_paragraphs)
        else:
           if self.author and not self.calling:
                result_text_paragraphs.append(text_paragraphs[0:1])
                result_text_paragraphs.append(text_paragraphs[2:])
           elif not self.author and self.calling:
                result_text_paragraphs.append(text_paragraphs[1:])
           elif not self.author and not self.calling:
                result_text_paragraphs.append(text_paragraphs[2:])
           else:
                result_text_paragraphs.append(text_paragraphs) 

        # Flatten the list using a list comprehension
        result_text_paragraphs = [item for sublist in result_text_paragraphs for item in sublist]
            
        extracted_text = '\n\n'.join(result_text_paragraphs)

        return extracted_text

    def _extract_metadata(self) -> dict:
        """Extracts metadata about the talk from the talk's transcript."""
        response = requests.get(self.url)
        soup = BeautifulSoup(response.content, 'html.parser')
        
        # Initialize a dictionary to store metadata
        metadata = {}

        # Extract title if available
        if self.title:
            title_header = soup.find('h1')
            metadata['title'] = title_header.get_text().strip() if title_header else None

        # Extract author if available
        if self.author:
            author_name = soup.find('p', id='author1')
            if not author_name:
                author_name = soup.find('p', class_='author-name')
            metadata['author'] = author_name.get_text().replace("By ", "").replace('Sister', '').replace('Elder', '').replace('President', '').replace('\xa0', ' ').strip() if author_name else None
            

        # Extract calling if available
        if self.calling:
            author_calling = soup.find('p', id='author2')
            if not author_calling:
                author_calling = soup.find('p', class_='author-role')
            metadata['calling'] = author_calling.get_text().strip() if author_calling else None
        
        # Extract year and month from URL
        match = re.search(r"/(\d{4})/(\d{2})", self.url)
        if match:
            metadata['year'] = int(match.group(1))
            metadata['month'] = int(match.group(2))

        # Include URL
        metadata['url'] = self.url
        
        return metadata
