# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/70_cfgs.ipynb.

# %% auto 0
__all__ = ['NoiseLike', 'ScaledNoiseLike', 'GaussianLike', 'AlphaLike', 'AlphasLike', 'IntegrationSpec', 'TimeSteps',
           'RegularizationSpec']

# %% ../nbs/70_cfgs.ipynb 6
from abc import ABCMeta, abstractmethod
from functools import wraps

# %% ../nbs/70_cfgs.ipynb 8
from types import FunctionType
from typing import Callable, Iterable, TypeAlias

# %% ../nbs/70_cfgs.ipynb 11
#| export

# %% ../nbs/70_cfgs.ipynb 13
try: import numpy as np
except ImportError: ...

try: import pandas as pd
except ImportError: ...

try: import matplotlib.pyplot as plt
except ImportError: ...

try: import seaborn as sns
except ImportError: ...

# %% ../nbs/70_cfgs.ipynb 14
try: from pandas.core.indexing import _LocIndexer, _iLocIndexer
except: ...
try: from pandas import Categorical, CategoricalIndex, RangeIndex, CategoricalDtype
except: ...
try: from pandas.io.formats import (format as pd_format)
except ImportError: ...

# %% ../nbs/70_cfgs.ipynb 16
try: import torch
except ImportError: ...

try: import torch, torch.nn as nn
except: ...

try: from torch.utils.data import Dataset, DataLoader
except: ...

try: import lightning as L
except: ...

try: from lightning import LightningDataModule
except: ...

# %% ../nbs/70_cfgs.ipynb 18
from nlit import LABEL, MPS
from chck import isnone, iscall, notnone, istensor, isnum
from quac import ptdevice, tensor
from sigr import get_signature_defaults

from utrc import (
    P, RegulationSpec as RegSpec, 
    generate_spans, generate_pairs, groupget,
    gauss_like, batch_zeros, zero_placeholder,
    integration_steps,  integration_space
)

# %% ../nbs/70_cfgs.ipynb 20
#| export


# %% ../nbs/70_cfgs.ipynb 23
class NoiseLike:
    def __init__(self, method: Callable | str | None = None):
        self.method = method or getattr(torch, method, torch.randn_like)
        
    def like(self, x: torch.Tensor, *args, **kwargs) -> torch.Tensor:
        base = dict(requires_grad=False,  dtype=x.dtype, device=x.device)
        kwds = get_signature_defaults(self.method, **{**kwargs, **base})
        return self.method(x, **kwds)
    
    def __call__(self, x: torch.Tensor) -> torch.Tensor:
        return x + self.like(x)

class ScaledNoiseLike(NoiseLike):
    def __init__(self, scale: float = 1., method: Callable | str | None = None):
        super().__init__(method)
        self.scale = scale
    
    def __call__(self, x: torch.Tensor) -> torch.Tensor:
        return x + self.scale * self.like(x)

class GaussianLike(ScaledNoiseLike):
    def __init__(self, scale: float = 1.):
        super().__init__(scale, torch.randn_like)

class AlphaLike(GaussianLike):
    alpha: nn.Parameter | None = None
    def __init__(self, scale: float | None = 1.):
        super().__init__(scale)
        if scale is not None:
            self.alpha = nn.Parameter(torch.tensor(scale, requires_grad=True).float())
        
    def __call__(self, x):
        if isnone(self.alpha): return x
        return x + (self.like(x) * self.alpha)
    
class AlphasLike(NoiseLike):
    scales: list[float] | None = None
    alphas: list[nn.Parameter] | None = None
    def __init__(self, scales: list[float] | None = 1. ):
        super().__init__(torch.randn_like)
        if notnone(scales):
            self.alphas = nn.Parameter(torch.tensor(scales, requires_grad=True).float())
        
    def __call__(self, x, t):
        if isnone(self.alphas): return x
        return x + (self.like(x) * self.alphas[int(t-1)])

# %% ../nbs/70_cfgs.ipynb 25
class IntegrationSpec:
    def __init__(self, imin: int = 2, imax: int = 100, inum: int | None = None):
        super().__init__()
        self.imin, self.imax, self.inum = imin, imax, inum
        
    def nstep(self, i: int | None = None, j: int | None = None, n: int | None = None):
        return (n or self.inum) or max(min((j or 1) - (i or 0), self.imax), self.imax)
    
    def space(self, i: int, j: int, n: int | None = None):
        return torch.linspace(i, j, self.nstep(i, j, n))
        
    def __call__(self, i: int, j: int, n: int | None = None): 
        return self.space(i, j, n)

# %% ../nbs/70_cfgs.ipynb 27
class TimeSteps:
    def __init__(
        self, steps: tensor[int] | list[int] | None = None, model: L.LightningModule | None = None, 
        tmin: int | None = None, tmax: int | None = None, **kwargs: P.kwargs
    ):
        super().__init__()
        t_step = getattr(model,  't_step', steps)
        if isnone(t_step):
            t_step = torch.linspace((tmin or 0), (tmax or 1), 2)
            
        if notnone(t_step) and not istensor(t_step): 
            t_step = torch.tensor(t_step)
            
        self.spec = t_step
        self._min = t_step.min().item()
        self._max = t_step.max().item()
        self._num = len(t_step)
    
    def __len__(self) -> int: return len(self.spec)
    def __call__(self): return self.spec
    def __iter__(self): return iter(self.spec)
    def __getitem__(self, idx): return self.spec[idx]
    
    @wraps(generate_pairs)
    def steps(self, n: int | None = None, i: int | None = None):
        return generate_pairs(self.t_step, (n or 2), (i or 1))
    
    @wraps(generate_spans)
    def spans(
        self, 
        init: int | None = None, 
        incr: int | None = None, 
        span: int | None = None, 
        stop: int | None = None, 
        include_stop: bool = True
    ):
        return generate_spans((init or self.tmin), (incr or 1), (span or 1), (stop or self.tmax), include_stop=include_stop)
    
    @property    
    def tnum(self) -> int: return int(self._num)
    @property    
    def tmin(self) -> int: return int(self._min)
    @property    
    def tmax(self) -> int: return int(self._max)
    
    
    def pair1(self): return self.steps(1, 1)
    def pair2(self): return self.steps(2, 1)
    def pair3(self): return self.steps(3, 1)
    def pair4(self): return self.steps(4, 1)
    def pair5(self): return self.steps(5, 1)
    def pair6(self): return self.steps(6, 1)
    def pair7(self): return self.steps(7, 1)
    def pair8(self): return self.steps(8, 1)
    def pair9(self): return self.steps(9, 1)
    def pair10(self): return self.steps(10, 1)
    
    def span1(self): return self.spans(self.tmin, 1, 1, self.tmax, True)
    def span2(self): return self.spans(self.tmin, 2, 1, self.tmax, True)
    def span3(self): return self.spans(self.tmin, 3, 1, self.tmax, True)
    def span4(self): return self.spans(self.tmin, 4, 1, self.tmax, True)
    def span5(self): return self.spans(self.tmin, 5, 1, self.tmax, True)
    def span6(self): return self.spans(self.tmin, 6, 1, self.tmax, True)
    def span7(self): return self.spans(self.tmin, 7, 1, self.tmax, True)
    def span8(self): return self.spans(self.tmin, 8, 1, self.tmax, True)
    def span9(self): return self.spans(self.tmin, 9, 1, self.tmax, True)
    def span10(self): return self.spans(self.tmin, 10, 1, self.tmax, True)    

# %% ../nbs/70_cfgs.ipynb 29
class RegularizationSpec:
    def __init__(self, spec: RegSpec):
        self.lmds, self.regs = self.parse(spec)
        
    def __len__(self): return len(self.regs)
    def __iter__(self): return zip(self.lmds, self.regs)
    def __getitem__(self, idx): return self.lmds[idx], self.regs[idx]
    
    @classmethod
    def parse(cls, spec: RegSpec) -> tuple[list[float], list[Callable]]:
        # spec is a single value
        if not isinstance(spec, (list, tuple, Iterable)) and iscall(spec): regs, lmds = [spec], [1.]
        
        # spec contains two lists one for losses the other for lambdas
        elif (
            len(spec) == 2 and 
            all(iscall(v) for v in spec[0]) and 
            all(isnum(v) for v in spec[-1])
        ):
            regs, lmds = spec
            
        elif (
            len(spec) == 2 and 
            all(isnum(v) for v in spec[0]) and
            all(iscall(v) for v in spec[-1]) 
        ):
            lmds, regs = spec
        
        # spec is a list of just losses
        elif isinstance(spec, (list, tuple, Iterable)): regs, lmds = spec, [1. for _ in spec]
        # spec is neither a callable item, a list of callables, or a list of callables / floats
        else: raise ValueError
        
        # pad lambdas
        if len(lmds) < len(regs): lmds = [*lmds] + [1.] * (len(regs)-len(lmds))
        return lmds, regs

# %% ../nbs/70_cfgs.ipynb 31
#| export

