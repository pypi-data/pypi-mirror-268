# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/60_dmod.ipynb.

# %% auto 0
__all__ = ['PandasDataModule', 'PandasCategoricalDataModule', 'PandasTimeSeriesDataModule']

# %% ../nbs/60_dmod.ipynb 6
from abc import abstractmethod

# %% ../nbs/60_dmod.ipynb 8
from types import FunctionType

# %% ../nbs/60_dmod.ipynb 11
#| export

# %% ../nbs/60_dmod.ipynb 13
try: import numpy as np
except ImportError: ...

try: import pandas as pd
except ImportError: ...

try: import matplotlib.pyplot as plt
except ImportError: ...

try: import seaborn as sns
except ImportError: ...

# %% ../nbs/60_dmod.ipynb 15
try: import torch
except ImportError: ...

try: import torch, torch.nn as nn
except: ...

try: from torch.utils.data import Dataset, DataLoader
except: ...

try: import lightning as L
except: ...

try: from lightning import LightningDataModule
except: ...

# %% ../nbs/60_dmod.ipynb 17
from nlit import LABEL, MPS
from quac import ptdevice
from chck import iscall, notnone
from sigr import get_keywords_from_reference
from utrc import P, get_categories, grouplens, drop_column, datasplit
from etrc import Stage

# %% ../nbs/60_dmod.ipynb 19
from .cons import DATASET_CLS, DATAFRAME_FN
from .util import DataSplits
from .make import diamonds
from .dset import PandasDataset, PandasCategoricalDataset, PandasTimeSeriesDataset

# %% ../nbs/60_dmod.ipynb 22
class PandasDataModule(L.LightningDataModule):
    '''Data module specifically designed for handling pandas DataFrames with PyTorch, providing customizable splits and data loading.

    This class can significantly simplify the setup and usage of PyTorch DataLoader when using pandas DataFrames, 
    including batch and collate configurations tailored to the needs of the model and training process.

    Attributes
    ----------
    df : pd.DataFrame
        The DataFrame containing the data.
        
    col : str
        The name of the column to use as labels.
        
    device : str | ptdevice | None
        The device to load the tensors to.
        
    labels : pd.Series | None
        Labels to use instead of extracting from the DataFrame.
        
    replace : bool
        Whether to sample with replacement.
        
    batch_size : int
        Batch size for DataLoader.
        
    collate_fn : callable
        Collate function for DataLoader.
        
    dataframe_fn : callable
        Function to generate a DataFrame if `df` is not provided during initialization.
        
    splits : DataSplits
        Dataset splits for fit, validation, test, and predict stages.
        
    dataset_cls : type
        Dataset class to wrap the DataFrame rows into dataset items.
    '''
    
    dl_kwargs: dict = dict(drop_last=True, shuffle=True)
    '''`torch.utils.data.DataLoader` Keywords''';
    
    shuffle: bool = True
    
    batch_size: int = 32
    '''batch size for `DataLoader`.''';
    
    collate_fn: FunctionType | None
    '''Collate function for `DataLoader`.''';
    
    dataframe_fn: FunctionType | None = diamonds
    '''Funciton to generate a `DataFrame` if `df` is not provided during initalization.''';
    
    splits: DataSplits = DataSplits(.7, .2, .1, .0)
    '''`Dataset` splits for fit, valid, test, pred.''';
    
    dataset_cls: FunctionType | None = PandasDataset
    '''`Dataset` class to wrap the `DataFrame` in.''';
    
    def __init__(
        self, 
        df: pd.DataFrame | None = None, 
        col: str = LABEL, 
        device: str | ptdevice | None = MPS, 
        *args, 
        replace: bool = False, 
        labels: pd.Series | None = None,
        splits: DataSplits | tuple[float, ...] | dict | None = None,
        dataframe_fn: FunctionType | None = None,
        dataset_cls: FunctionType | None = None,
        **kwargs
    ):
        '''Initializes the data module with the DataFrame or the function to create it.
        
        Parameters
        ----------
        df : pd.DataFrame | None
            The DataFrame to wrap. If None, `dataframe_fn` will be used to create it.
            
        col : str, default: 'label'
            The column name to use as labels.
            
        device : str | ptdevice | None, default: 'mps'
            The device on which the tensors will be allocated.

        replace : bool, default: False
            Whether to sample with replacement during data loading.

        labels : pd.Series | None, optional
            Explicit labels to use instead of extracting from the DataFrame.

        splits : DataSplits | tuple[float, ...] | dict | None, optional
            Custom splits for the data sets.
            
        dataframe_fn : FunctionType | None, optional
            A function to generate the DataFrame if `df` is None.
            
        dataset_cls : FunctionType | None, optional
            The class to wrap DataFrame rows into dataset items.
            
        **kwargs
            Additional keyword arguments for DataLoader keyword construction.
        '''
        super().__init__()
        self.df = df
        self.column = col
        self.labels = labels or get_categories(df, col).values
        self.n_feat = len(df.columns) - (1 if col in df.columns else 0)
        self.device = device
        self.replace = replace
        self.dataframe_fn = getattr(type(self), DATAFRAME_FN, dataframe_fn)
        self.dataset_cls = getattr(type(self), DATASET_CLS, dataset_cls)
                
        if (splits := DataSplits.make(splits)): self.splits = splits
        self.dl_kwargs = self.dataloader_kwds(**kwargs)
        
        
    def __len__(self) -> int:
        '''Returns the total number of items in the `DataFrame`.'''
        return self.df.shape[0]
    
    def dataloader_kwds(self, **kwargs: P.kwargs) -> dict:
        '''Returns custom `DataLoader` keyword arguments based on the provided defaults and overrides.'''
        return get_keywords_from_reference(DataLoader, self, __refkws=self.dl_kwargs, **kwargs)
        
    def dataframe_kwds(self, **kwargs: P.kwargs) -> dict:
        '''Returns keyword arguments for initializing the DataFrame using `dataframe_fn`.'''
        if notnone(getattr(self, DATAFRAME_FN, None)):
            return get_keywords_from_reference(self.dataframe_fn, self,**kwargs)
        return dict()
        
    def prepare_data(self, **kwargs: P.kwargs):
        '''Prepares the DataFrame using the `dataframe_fn` if it was not provided during initialization.'''
        df_fn = kwargs.get(DATAFRAME_FN, self.dataframe_fn)
        if self.df is None and iscall(df_fn):
            kws = self.dataframe_kwds(**kwargs)
            self.df = df_fn(**kws)
        return self
    
    def setup(self, stage: str | Stage = None):
        '''Sets up datasets for training, validation, testing, or prediction based on the stage.'''
        (self.train_idx, self.valid_idx, self.test_idx, self.pred_idx) = \
            datasplit(drop_column(self.df, self.column), splits=self.splits.astuple(), retdfs=False)
        
        if stage == Stage.fit or stage is None:
            self.train_ds = self.dataset_cls(self.df.iloc[self.train_idx], self.column, self.device)
            self.valid_ds = self.dataset_cls(self.df.iloc[self.valid_idx], self.column, self.device)
        
        if stage == Stage.test or stage is None:
            self.test_ds = self.dataset_cls(self.df.iloc[self.test_idx], self.column, self.device)
        
        if stage == Stage.predict or stage is None:
            self.pred_ds = self.dataset_cls(self.df.iloc[self.pred_idx], self.column, self.device)
            
        return self

    def train_dataloader(self) -> DataLoader:
        '''Provides the `DataLoader` for training.'''
        return DataLoader(self.train_ds, **self.dl_kwargs)

    def val_dataloader(self) -> DataLoader:
        '''Provides the `DataLoader` for validation.'''
        return DataLoader(self.valid_ds, **self.dl_kwargs)
    
    def test_dataloader(self) -> DataLoader:
        '''Provides the `DataLoader` for testing.'''
        return DataLoader(self.test_ds, **self.dl_kwargs)

    def predict_dataloader(self) -> DataLoader:    
        '''Provides the `DataLoader` for prediction.'''  
        return DataLoader(self.pred_ds, **self.dl_kwargs)

    def teardown(self, stage: str | Stage):
        '''Cleanup any state assigned during setup.'''

# %% ../nbs/60_dmod.ipynb 24
class PandasCategoricalDataModule(PandasDataModule):
    '''Data module specifically designed for categorical datasets derived from pandas DataFrames.

    This class can significantly simplify the setup and usage of PyTorch DataLoader when using pandas DataFrames, 
    including batch and collate configurations tailored to the needs of the model and training process.

    Attributes
    ----------
    df : pd.DataFrame
        The DataFrame containing the data.
        
    col : str
        The name of the column to use as labels.
        
    device : str | ptdevice | None
        The device to load the tensors to.
        
    labels : pd.Series | None
        Labels to use instead of extracting from the DataFrame.
        
    replace : bool
        Whether to sample with replacement.
        
    batch_size : int
        Batch size for DataLoader.
        
    collate_fn : callable
        Collate function for DataLoader.
        
    dataframe_fn : callable
        Function to generate a DataFrame if `df` is not provided during initialization.
        
    splits : DataSplits
        Dataset splits for fit, validation, test, and predict stages.
        
    dataset_cls : type
        Dataset class to wrap the DataFrame rows into dataset items.
    '''
    

    collate_fn = PandasCategoricalDataset.collate_fn
    dataset_cls: FunctionType | None = PandasCategoricalDataset
    
    def __init__(self, df: pd.DataFrame, col: str = LABEL, device: str = MPS, *args: P.args, **kwargs: P.kwargs):
        '''
        Parameters
        ----------
        df : pd.DataFrame | None
            The DataFrame to wrap. If None, `dataframe_fn` will be used to create it.
            
        col : str, default: 'label'
            The column name to use as labels.
            
        device : str | ptdevice | None, default: 'mps'
            The device on which the tensors will be allocated.

        replace : bool, default: False
            Whether to sample with replacement during data loading.

        labels : pd.Series | None, optional
            Explicit labels to use instead of extracting from the DataFrame.

        splits : DataSplits | tuple[float, ...] | dict | None, optional
            Custom splits for the data sets.
            
        dataframe_fn : FunctionType | None, optional
            A function to generate the DataFrame if `df` is None.
            
        dataset_cls : FunctionType | None, optional
            The class to wrap DataFrame rows into dataset items.
            
        **kwargs
            Additional keyword arguments for DataLoader keyword construction.
        '''
        super().__init__(df, col, device, *args, **kwargs)
        self.n_cats = len(self.labels)
        
    def __len__(self) -> int:
        '''Returns the length of the shortest category group in the `DataFrame`.'''
        return min(grouplens(self.df, self.column))

# %% ../nbs/60_dmod.ipynb 26
class PandasTimeSeriesDataModule(PandasCategoricalDataModule):
    '''Data module for time series data handling, extending categorical capabilities to time-indexed data.

    This class can significantly simplify the setup and usage of PyTorch DataLoader when using pandas DataFrames, 
    including batch and collate configurations tailored to the needs of the model and training process.

    Attributes
    ----------
    df : pd.DataFrame
        The DataFrame containing the data.
        
    col : str
        The name of the column to use as labels.
        
    device : str | ptdevice | None
        The device to load the tensors to.
        
    labels : pd.Series | None
        Labels to use instead of extracting from the DataFrame.
        
    replace : bool
        Whether to sample with replacement.
        
    batch_size : int
        Batch size for DataLoader.
        
    collate_fn : callable
        Collate function for DataLoader.
        
    dataframe_fn : callable
        Function to generate a DataFrame if `df` is not provided during initialization.
        
    splits : DataSplits
        Dataset splits for fit, validation, test, and predict stages.
        
    dataset_cls : type
        Dataset class to wrap the DataFrame rows into dataset items.
    '''

    collate_fn = PandasCategoricalDataset.collate_fn
    
    dataset_cls: FunctionType | None = PandasTimeSeriesDataset
    
    def __init__(self, df: pd.DataFrame, col: str = LABEL, device: str = MPS, *args: P.args, **kwargs: P.kwargs):
        '''
        Parameters
        ----------
        df : pd.DataFrame | None
            The DataFrame to wrap. If None, `dataframe_fn` will be used to create it.
            
        col : str, default: 'label'
            The column name to use as labels.
            
        device : str | ptdevice | None, default: 'mps'
            The device on which the tensors will be allocated.

        replace : bool, default: False
            Whether to sample with replacement during data loading.

        labels : pd.Series | None, optional
            Explicit labels to use instead of extracting from the DataFrame.

        splits : DataSplits | tuple[float, ...] | dict | None, optional
            Custom splits for the data sets.
            
        dataframe_fn : FunctionType | None, optional
            A function to generate the DataFrame if `df` is None.
            
        dataset_cls : FunctionType | None, optional
            The class to wrap DataFrame rows into dataset items.
            
        **kwargs
            Additional keyword arguments for DataLoader keyword construction.
        '''
        super().__init__(df, col, device, *args, **kwargs)
        self.t_dict = dict(enumerate(self.labels))
        self.t_step = torch.linspace(0, self.n_cats - 1, self.n_cats)

# %% ../nbs/60_dmod.ipynb 38
#| export

