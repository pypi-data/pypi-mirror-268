# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/50_dset.ipynb.

# %% auto 0
__all__ = ['PandasDataset', 'PandasCategoricalDataset', 'PandasTimeSeriesDataset']

# %% ../nbs/50_dset.ipynb 6
from functools import wraps, partial
from abc import abstractmethod

# %% ../nbs/50_dset.ipynb 8
from types import FunctionType
from typing import Callable, Optional

# %% ../nbs/50_dset.ipynb 11
#| export

# %% ../nbs/50_dset.ipynb 13
try: import numpy as np
except ImportError: ...

try: import pandas as pd
except ImportError: ...

try: import matplotlib.pyplot as plt
except ImportError: ...

try: import seaborn as sns
except ImportError: ...

# %% ../nbs/50_dset.ipynb 15
try: import torch
except ImportError: ...

try: import torch, torch.nn as nn
except: ...

try: from torch.utils.data import Dataset, DataLoader, IterableDataset, TensorDataset
except: ...

# %% ../nbs/50_dset.ipynb 17
from nlit import LABEL, MPS
from quac import ptdevice
from chck import isslice
from asto import slice2range

from utrc import P, get_categories, grouplens

# %% ../nbs/50_dset.ipynb 19
from .make import diamonds
from .cats import torch_categorical_sample, categorical_collate_fn

# %% ../nbs/50_dset.ipynb 22
class PandasDataset(Dataset):
    '''A dataset wrapper for a Pandas DataFrame to interface with PyTorch data loaders.

    This dataset allows for easy interfacing with PyTorch's DataLoader class, which can
    improve performance and usability when training machine learning models.

    Attributes
    ----------
    df : pd.DataFrame
        The DataFrame containing the data.
        
    col : str
        The name of the column to use as labels.
        
    device : str | ptdevice | None
        The device to load the tensors to.
        
    labels : pd.Series | None
        Labels to use instead of extracting from the DataFrame.
        
    replace : bool
        Whether to sample with replacement.
    '''
    
    def __init__(
        self, 
        df: pd.DataFrame, 
        col: str = LABEL, 
        device: str | ptdevice | None = MPS, 
        *args: P.args, 
        replace: bool = False, 
        labels: pd.Series | None = None, 
        **kwargs: P.kwargs
    ):
        '''Initialize the dataset with a DataFrame.
        
        Parameters
        ----------
        df : pd.DataFrame
            The DataFrame containing the data.
            
        col : str, default: 'label'
            The name of the column to use as labels.
            
        device : str | ptdevice | None, default: 'mps'
            The device to load the tensors to.
            
        replace : bool, default: False
            Whether to sample with replacement.
            
        labels : pd.Series | None
            An optional series of labels if not to use the unique values in the column `col`.
        '''
        super().__init__()
        self.df = df
        self.column = col
        self.labels = labels or get_categories(df, col).values
        self.n_feat = len(df.columns) - (1 if col in df.columns else 0)
        self.device = device
        self.replace = replace
        
    def __len__(self) -> int:
        '''Returns the number of items in the dataset.'''
        return self.df.shape[0]

# %% ../nbs/50_dset.ipynb 24
class PandasCategoricalDataset(PandasDataset):
    '''
    A categorical dataset that uses a pandas DataFrame and provides samples through one-hot encoding of categories.
    
    This dataset allows for easy interfacing with PyTorch's DataLoader class, which can
    improve performance and usability when training machine learning models.

    Attributes
    ----------
    df : pd.DataFrame
        The DataFrame containing the data.
        
    col : str
        The name of the column to use as labels.
        
    device : str | ptdevice | None
        The device to load the tensors to.
        
    labels : pd.Series | None
        Labels to use instead of extracting from the DataFrame.
        
    replace : bool
        Whether to sample with replacement.
        
    n_cats : int
        Number of unique categories/labels.
    '''

    def __init__(
        self, 
        df: pd.DataFrame, 
        col: str = LABEL, 
        device:  str | ptdevice | None = MPS, 
        *args: P.args, 
        replace: bool = False, 
        labels: pd.Series | None = None, 
        **kwargs: P.kwargs
    ):
        '''
        Initialize the categorical dataset with a DataFrame.
        
        Parameters
        ----------
        df : pd.DataFrame
            The DataFrame containing the data.
            
        col : str, default: 'label'
            The name of the column to use as labels for one-hot encoding.
            
        device : str | ptdevice | None, default: 'mps'
            The device to load the tensors to.
            
        replace : bool, default: False
            Whether to sample with replacement.
            
        labels : pd.Series | None
            Specific labels to use for categorical conversion. If None, it will find unique values in `col`.
            
        Returns
        -------
        None
        '''
        super().__init__(df, col, device, *args, replace=replace, labels=labels, **kwargs)
        self.n_cats = len(self.labels)

    def __len__(self) -> int:
        '''Returns the minimal group length based on categorical column grouping.'''

        return min(grouplens(self.df, self.column))
    
    @classmethod
    def collate_fn(cls, xys: tuple[tuple[torch.Tensor, torch.Tensor], ...]) -> tuple[tuple[torch.Tensor, torch.Tensor], ...]:
        '''Custom collate function to process batches of tensors.
        
        Parameters
        ----------
        xys : tuple[tuple[torch.Tensor, torch.Tensor], ...]
            A tuple of (sample, label) pairs.
            
        Returns
        -------
        tuple
            Batch of samples and labels processed as per categorical requirements.
        '''
        return categorical_collate_fn(xys)

    def __getitem__(self, idx):
        '''Retrieve an item or slice from the dataset.
        
        Parameters
        ----------
        idx : int | slice
            The index or slice indicating which item(s) to fetch.
            
        Returns
        -------
        tuple
            The sample and its corresponding label tensor.
        '''
        n = len(slice2range(idx)) if isslice(idx) else 1
        samples, labels = torch_categorical_sample(
            df=self.df, col=self.column, n=n, replace=self.replace, device=self.device)
        return samples, labels

# %% ../nbs/50_dset.ipynb 25
class PandasTimeSeriesDataset(PandasCategoricalDataset):
    '''
    A categorical dataset that uses a pandas DataFrame and provides samples through one-hot encoding of categories.
    
    This dataset allows for easy interfacing with PyTorch's DataLoader class, which can
    improve performance and usability when training machine learning models.

    Attributes
    ----------
    df : pd.DataFrame
        The DataFrame containing the data.
        
    col : str
        The name of the column to use as labels.
        
    device : str | ptdevice | None
        The device to load the tensors to.
        
    labels : pd.Series | None
        Labels to use instead of extracting from the DataFrame.
        
    replace : bool
        Whether to sample with replacement.
        
    n_cats : int
        Number of unique categories/labels.
        
    t_dict : dict
        Dictionary mapping time steps to indices.
    
    t_step : torch.Tensor
        Tensor of time steps.
    '''

    def __init__(
        self, 
        df: pd.DataFrame, 
        col: str = LABEL, 
        device: str | ptdevice | None = MPS, 
        *args: P.args, 
        replace: bool = False, 
        labels: pd.Series | None = None, 
        **kwargs: P.kwargs
    ):
        '''Initialize the time series dataset with a DataFrame.
        
        Parameters
        ----------
        df : pd.DataFrame
            The DataFrame containing the data.
            
        col : str, default: 'label'
            The name of the column to use as time labels.
            
        device : str | ptdevice | None, default: 'mps'
            The device to load the tensors to.
            
        replace : bool, default: False
            Whether to sample with replacement.
            
        labels : pd.Series | None
            Specific labels to use for time indexing. If None, it will find unique values in `col`.
            
        Returns
        -------
        None
        '''
        super().__init__(df, col, device, *args, replace=replace, labels=labels, **kwargs)
        self.t_dict = dict(enumerate(self.labels))
        self.t_step = torch.linspace(0, self.n_cats - 1, self.n_cats)

# %% ../nbs/50_dset.ipynb 32
#| export

