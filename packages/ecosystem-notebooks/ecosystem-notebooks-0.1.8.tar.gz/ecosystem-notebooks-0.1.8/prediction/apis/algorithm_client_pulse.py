from prediction.endpoints import algorithm_client_pulse as endpoints
from prediction import request_utils

def get_timeline(auth, user, limit, info=False):
# Get Timeline:
#   auth: Authentication token generated by jwt_access.Authenticate()
#   user: User name (string)
#   limit: Output limit (int)
	ep = endpoints.GET_TIMELINE
	param_dict = {
		"user": user, 
		"limit": limit
	}
	resp = request_utils.create(auth, ep, params=param_dict, info=info)
	meta = resp.json()
	return meta

def process_basket(auth, dbcust, colcust, searchcust, custfield, dbitem, colitem, itemfield, supportcount, info=False):
# Process Basket:
#   auth: Authentication token generated by jwt_access.Authenticate()
#   dbcust: (str)
#   colcust: (str)
#   searchcust: (str)
#   custfield: (str)
#   dbitem: (str)
#   colitem: (str)
#   itemfield: (str)
#   supportcount: (int)
	ep = endpoints.PROCESS_BASKET
	param_dict = {
		"dbCust": dbcust, 
		"colCust": colcust,
		"searchCust": searchcust,
		"custField": custfield,
		"dbItem": dbitem,
		"colItem": colitem,
		"itemField": itemfield,
		"supportCount": supportcount
	}
	resp = request_utils.create(auth, ep, params=param_dict, info=info)
	meta = resp.json()
	return meta

def process_directed_graph(auth, graphMeta, graphParam, info=False):
# Analyze graph from data using graph meta data and analysis parameters. 
# Meta data format example: {"vertex":[0,1],"edges":[{"from":0,"to":1}],"from":0,"source":"/data/data.csv","dotfile":"/data/data.dot","to":1} Analysis parameter example: {"destination":"Bakeries","source":"12345678"} 
# Columns in file start at 0 and is sequenced.
#   auth: Authentication token generated by jwt_access.Authenticate()
#   graphMeta: (str)
#   graphParam: (str)
	ep = endpoints.PROCESS_BASKET
	param_dict = {
		"graphMeta": graphMeta, 
		"graphParam": graphParam
	}
	resp = request_utils.create(auth, ep, params=param_dict, info=info)
	meta = resp.json()
	return meta


def generate_forecast(auth, attribute, collection, collectionOut, database, dateattribute, find, historicsteps, steps, info=False):
	ep = endpoints.GENERATE_FORECAST
	param_dict = {
		"attribute": attribute,
		"collection": collection,
		"collectionOut": collectionOut,
		"database": database,
		"dateattribute": dateattribute,
		"find": find,
		"historicsteps": historicsteps,
		"steps": steps
	}
	resp = request_utils.create(auth, ep, params=param_dict, info=info)
	meta = resp.json()
	return meta

def process_apriori(auth, colItem, collection, collectionOut, custField, database, dbItem, find, itemField, supportCount, info=False):
	ep = endpoints.PROCESS_APRIORI
	param_dict = {
		"colItem": colItem,
		"collection": collection,
		"collectionOut": collectionOut,
		"custField": custField,
		"database": database,
		"dbItem": dbItem,
		"find": find,
		"itemField": itemField,
		"supportCount": supportCount
	}
	resp = request_utils.create(auth, ep, params=param_dict, info=info)
	meta = resp.json()
	return meta

def process_ecogenetic_network(auth, collection, collectionOut, database, find, graphMeta, graphParam, info=False):
	ep = endpoints.PROCESS_ECOGENETIC_NETWORK
	param_dict = {
		"collection": collection,
		"collectionOut": collectionOut,
		"database": database,
		"find": find,
		"graphMeta": graphMeta,
		"graphParam": graphParam
	}
	resp = request_utils.create(auth, ep, params=param_dict, info=info)
	meta = resp.json()
	return meta

def process_directed_graph2(auth, db, collection, collection_out, graphMeta, graphParam, info=False):
# Analyze graph from data using graph meta data and analysis parameters. 
# Meta data format example: {"vertex":[0,1],"edges":[{"from":0,"to":1}],"from":0,"source":"/data/data.csv","dotfile":"/data/data.dot","to":1} Analysis parameter example: {"destination":"Bakeries","source":"12345678"} 
# Columns in file start at 0 and is sequenced.
#   auth: Authentication token generated by jwt_access.Authenticate()
#   graphMeta: (str)
#   graphParam: (str)
	ep = endpoints.PROCESS_DIRECTED_GRAPH2
	param_dict = {
		"database": db,
		"collection": collection,
		"collectionOut": collection_out,
		"graphMeta": graphMeta,
		"graphParam": graphParam
	}
	resp = request_utils.create(auth, ep, params=param_dict, info=info)
	meta = resp.json()
	return meta

def generate_cox_ph_data(auth, collection, collection_out, customer_field, database, database_out, date_field, find, info=False):
	ep = endpoints.GENERATE_COX_PH_DATA
	param_dict = {
		"collection": collection, 
		"collectionOut": collection_out,
		"customer_field": customer_field,
		"database": database,
		"databaseOut": database_out,
		"date_field": date_field,
		"find": find
	}
	resp = request_utils.create(auth, ep, params=param_dict, info=info)
	meta = resp.json()
	return meta

def process_arima_forecast(auth, json, info=False):
	ep = endpoints.PROCESS_ARIMA_FORECAST
	resp = request_utils.create(auth, ep, json=json, info=info)
	response = resp.json()
	return response



def list_pulse_responder_dynamic(auth, info=False):
	ep = endpoints.LIST_PULSE_RESPONDER_DYNAMIC
	resp = request_utils.create(auth, ep, info=info)
	result = resp.json()
	return result

def delete_pulse_responder_dynamic(auth, db, collection, find, info=False):
	ep = endpoints.DELETE_PULSE_RESPONDER_DYNAMIC
	param_dict = {
		"database": db,
		"collection": collection,
		"find": find,
	}
	resp = request_utils.create(auth, ep, params=param_dict, info=info)
	result = resp.json()
	return result

def get_pulse_responder_messages(auth, db, collection, info=False):
	ep = endpoints.GET_PULSE_RESPONDER_MESSAGES
	param_dict = {
		"database": db,
		"collection": collection,
	}
	resp = request_utils.create(auth, ep, params=param_dict, info=info)
	result = resp.json()
	return result

def get_pulse_responder_options(auth, params, info=False):
	ep = endpoints.GET_PULSE_RESPONDER_OPTIONS
	param_dict = {
		"params": params,
	}
	resp = request_utils.create(auth, ep, params=param_dict, info=info)
	result = resp.json()
	return result

def get_pulse_responder_profile(auth, db, collection, info=False):
	ep = endpoints.GET_PULSE_RESPONDER_PROFILE
	param_dict = {
		"database": db,
		"collection": collection,
	}
	resp = request_utils.create(auth, ep, params=param_dict, info=info)
	result = resp.json()
	return result

def update_client_pulse_responder(auth, json, info=False):
	ep = endpoints.UPDATE_CLIENT_PULSE_RESPONDER
	resp = request_utils.create(auth, ep, json=json, info=info)
	response = resp.json()
	return response

def save_pulse_responder_dynamic(auth, json, info=False):
	ep = endpoints.SAVE_PULSE_RESPONDER_DYNAMIC
	resp = request_utils.create(auth, ep, json=json, info=info)
	response = resp.json()
	return response