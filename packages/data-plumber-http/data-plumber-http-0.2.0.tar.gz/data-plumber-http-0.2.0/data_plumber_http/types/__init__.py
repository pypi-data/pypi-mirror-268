from typing import Any
from dataclasses import dataclass
import abc


class _DPType(metaclass=abc.ABCMeta):
    @property
    @abc.abstractmethod
    def TYPE(self):
        raise NotImplementedError(
            "Property 'TYPE' needs to be defined when using abstract base '_DPType'."
        )

    @abc.abstractmethod
    def make(self, json, loc: str) -> tuple[Any, str, int]:
        raise NotImplementedError(
            "Method 'make' needs to be defined when using abstract base '_DPType'."
        )

    @property
    def __name__(self):
        return self.TYPE.__name__

    def __or__(self, other):
        class _(_DPType):
            _TYPES = [self, other]
            TYPE = self.TYPE | other.TYPE
            __name__ = f"{self.__name__} | {other.__name__}"
            def make(self, json, loc: str) -> tuple[Any, str, int]:
                # iterate all possible make-methods in _TYPES
                last = None
                for _type in self._TYPES:
                    # check whether types match at all
                    if not isinstance(json, _type.TYPE):
                        continue
                    # try to make instance of _DPType
                    last = _type.make(json, loc)
                    # try next option if not successful
                    if last[2] != Responses.GOOD.status:
                        continue
                    # return if everything went well
                    return (
                        last[0],
                        Responses.GOOD.msg,
                        Responses.GOOD.status
                    )
                # return info from latest attempt of making an instance
                if last is not None:
                    return (None, last[1], last[2])
                # never made a type-match > raise error
                raise ValueError(
                    "Union type constructor called with bad type. "
                    + f"'{type(json).__name__}' not in '{self.__name__}'."
                )
        return _()


@dataclass
class _ProblemInfo:
    status: int
    msg: str


class Responses:
    GOOD = _ProblemInfo(0, "")
    MISSING_OPTIONAL = _ProblemInfo(1, "")
    UNKNOWN_PROPERTY = _ProblemInfo(
        400,
        "Argument '{}' in '{}' not allowed (accepted: {})."
    )
    MISSING_REQUIRED = _ProblemInfo(
        400,
        "Object '{}' missing required property '{}'."
    )
    BAD_TYPE = _ProblemInfo(
        422,
        "Argument '{}' in '{}' has bad type. Expected '{}' but found '{}'."
    )
    BAD_VALUE = _ProblemInfo(
        422,
        "Value '{}' in '{}' not allowed (expected {})."
    )
    RESOURCE_NOT_FOUND = _ProblemInfo(
        404,
        "Could not find requested resource '{}' given in '{}'."
    )
    CONFLICT = _ProblemInfo(
        409,
        "Resource '{}' given in '{}' conflicts with existing resource."
    )


class Output(dict):
    """
    Type of the data-object in `Pipeline` generated from
    `Object.assemble`.

    Inherits from `dict` but provides the two properties
    kwargs -- `kwargs`-dictionary which has been generated by the
              `Object.assemble`-`Pipeline`
    value -- `Object.model`-object instantiated using `kwargs`
    """
    @property
    def value(self) -> Any:
        return self.get("value", None)

    @value.setter
    def value(self, value):
        self["value"] = value

    @property
    def kwargs(self) -> dict:
        return self.get("kwargs", {})

    @kwargs.setter
    def kwargs(self, kwargs):
        self["kwargs"] = kwargs


from .array import Array
from .boolean import Boolean
from .float import Float
from .integer import Integer
from .number import Number
from .object import Object
from .string import String
from .url import Url
from .file_system_object import FileSystemObject


__all__ = [
    "Responses",
    "Array", "Boolean", "Float", "Integer", "Number", "Object", "String",
    "Url", "FileSystemObject",
]
