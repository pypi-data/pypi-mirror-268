# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_misc.ipynb.

# %% auto 0
__all__ = ['drop_named_index', 'drop_column', 'groupget', 'grouplens', 'get_categories', 'pair', 'steps', 'increment_pairs',
           'generate_pairs', 'pair_elements', 'generate_steps', 'generate_spans', 'spans', 'pairwise_step', 'calcgrid',
           'grididx', 'pad4grid', 'takekeys']

# %% ../nbs/10_misc.ipynb 6
import math
from functools import wraps, singledispatch
from itertools import takewhile, count, zip_longest

# %% ../nbs/10_misc.ipynb 8
from numbers import Number
from typing import Generator, Iterator, Iterable, overload

# %% ../nbs/10_misc.ipynb 11
#| export

# %% ../nbs/10_misc.ipynb 13
try: import pandas as pd
except: ...

# %% ../nbs/10_misc.ipynb 15
#| export


# %% ../nbs/10_misc.ipynb 17
#| export


# %% ../nbs/10_misc.ipynb 19
from atup import fillnone
from nlit import LABEL, IGNORE, CATEGORY
from quac import nums, rect, xypos, groupkey
from chck import isdict

# %% ../nbs/10_misc.ipynb 21
from .cons import WRAPS_ASSIGN_ANNDOCS
from .strs import is_not_named

# %% ../nbs/10_misc.ipynb 23
def drop_named_index(df: pd.DataFrame) -> pd.DataFrame:
    '''Reset index of the DataFrame if it is not named.'''
    return df.reset_index(drop=is_not_named(df))

def drop_column(df: pd.DataFrame, col: str = LABEL) -> pd.DataFrame:
    '''Drop the specified column from a DataFrame and reset the index if it is not named.'''
    return drop_named_index(df).drop(columns=[col], errors=IGNORE)

def groupget(
    df: pd.DataFrame, 
    groupby: str | tuple | tuple[groupkey, ...], 
    group: str | tuple | groupkey,
    index: str = LABEL, 
    set_index: bool = False
) -> pd.DataFrame:
    '''Retrieve a specific group from a DataFrame grouped by the specified column(s).

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to group and retrieve from.
    
    groupby : str | tuple | tuple[groupkey, ...]
        Column name(s) to group by.
        
    group : str | tuple | groupkey
        The specific group's name or key to retrieve.
        
    index : str, default: 'LABEL'
        The column name to set as the new index of the subgroup if `set_index` is True.
        
    set_index : bool, default: True
        Determines whether to set the specified column as the new index for the subgroup.

    Returns
    -------
    pd.DataFrame
        The DataFrame containing only the rows belonging to the specified group.
    '''
    sub = drop_named_index(df).groupby(groupby, observed=False).get_group(group)
    if set_index: sub = sub.set_index(index)
    return sub

def grouplens(df: pd.DataFrame, groupby: str | tuple | tuple[groupkey, ...] = LABEL) -> pd.Series:
    '''Calculate the number of samples per category in a DataFrame.'''
    return drop_named_index(df).groupby(groupby, observed=False).agg(len).mean(axis=1).astype(int)

def get_categories(df: pd.DataFrame, col: str = LABEL) -> pd.Series:
    return pd.Series(sorted(drop_named_index(df)[col].astype(CATEGORY).unique()), name=col)

# %% ../nbs/10_misc.ipynb 25
def pair(a: nums, n: int = 2, i: int = 1) -> tuple[nums, ...]:
    '''Pair numbers in an array
    
    Parameters
    ----------
    a: ints
        array iterable of numbers to pair
        
    n: int
        The number to of elements pair in each tuple
        
    i: int
        The number to increment between elements in `a`
        
    Returns
    -------
    tuple[ints, ...]
        tuple of paired numbers each containing `n` paired elements from `a`.
        
    Examples
    --------
    >>> pair(np.arange(1, 6), 2)
    [(1, 2), (2, 3), (3, 4), (4, 5)]
    
    >>> pair(np.arange(1, 6), 3)
    [(1, 2, 3), (2, 3, 4), (3, 4, 5)]
    
    >>> pair(np.arange(1, 6), 2, 2)
    [(1, 3), (2, 4), (3, 5)]
    
    See Also
    --------
    steps: Alias for `pair`.
    '''
    if not isinstance(a, Iterable): a = [a]
    return tuple(zip(a, *(a[(i * _):] for _ in range(1, n))))

@wraps(pair, assigned=WRAPS_ASSIGN_ANNDOCS)
def steps(*args, **kwargs):
    '''Alias for `pair`.'''
    return pair(*args, **kwargs)

@wraps(pair, assigned=WRAPS_ASSIGN_ANNDOCS)
def increment_pairs(*args, **kwargs):
    return pair(*args, **kwargs)

@wraps(pair, assigned=WRAPS_ASSIGN_ANNDOCS)
def generate_pairs(*args, **kwargs):
    return pair(*args, **kwargs)

@wraps(pair, assigned=WRAPS_ASSIGN_ANNDOCS)
def pair_elements(*args, **kwargs):
    return pair(*args, **kwargs)

# %% ../nbs/10_misc.ipynb 28
@overload
def generate_steps(stop: int, *, include_stop: bool = True): ...
@overload
def generate_steps(step: int , stop: int, *, include_stop: bool = True): ...
@overload
def generate_steps(incr: int, step: int, stop: int, *, include_stop: bool = True): ...
@overload
def generate_steps(init: int, incr: int, step: int, stop: int, *, include_stop: bool = True): ...
def generate_steps(*args, include_stop: bool = True):
    '''
    Generate a list of tuples representing step intervals from 0 up to stop,
    incrementing by incr and ensuring each step interval does not exceed step.
    
    Parameters
    ----------
    init : int, default: 0
        The initial value to start at.
    incr : int
        The increment between each start of the step intervals.
    step : int
        The maximum allowed difference between the start and end of each interval.
    stop : int
        The stopping point for the generation of intervals.
        
    include_stop : bool, default: True
        Whether or not to include the stop value in the incrementations
    
    Returns
    -------
    list of tuples
        A list of tuples, where each tuple contains the start and end of each step interval.
        
    Examples
    --------
    >>> incr = 3
    ... step = 2
    ... stop = 10
    ... vals = generate_steps(incr, step, stop)

    ... firstvals = [v[0] for v in vals]
    ... firstdiff = tuple(b - a for a, b in zip(firstvals, firstvals[1:]))

    ... step_diff = tuple(b - a for a, b in vals)
    ... good_step = all(e <= step for e in step_diff)

    ... good_end = vals[-1][-1] == stop
    ... good_inc = all(e == incr for e in firstdiff)

    ... # each tuple increments by +incr, has a (a, b) diff of <= step and ends at stop
    ... all_valid = good_inc and good_step and good_end
    ... vals, all_valid

    '''
    init, incr, step, stop = 0, 1, 1, 1 
    match len(args):
        case 0:
            init, incr, step, stop = 0, 1, 1, 1 
        case 1: 
            stop, *_ = args
        case 2: 
            step, stop, *_ = args
        case 3: 
            incr, step, stop, *_ = args
        case 4: 
            init, incr, step, stop, *_ = args
        case _:
            init, incr, step, stop, *_ = args
    
    # Use takewhile to generate values up to the stop condition
    vals_gen = takewhile(lambda x: x + init < stop, count(0, incr))
    
    # Generate the list of tuples with the specified conditions
    vals = [((i + init), min((i + init) + step, (stop if include_stop else stop - 1))) for i in vals_gen]
    return vals

# %% ../nbs/10_misc.ipynb 30
@wraps(generate_steps, assigned=WRAPS_ASSIGN_ANNDOCS)
def generate_spans(*args, **kwargs):
    return generate_steps(*args, **kwargs)

@wraps(generate_steps, assigned=WRAPS_ASSIGN_ANNDOCS)
def spans(*args, **kwargs):
    return generate_steps(*args, **kwargs)


@wraps(generate_steps, assigned=WRAPS_ASSIGN_ANNDOCS)
def pairwise_step(*args, **kwargs):
    return generate_steps(*args, **kwargs)

# %% ../nbs/10_misc.ipynb 33
def calcgrid(n: int) -> rect:
    '''
    Find the closest rectangle layout that accommodates n elements.

    Parameters
    ----------
    n : int
        The number of elements to accommodate in the grid.

    Returns
    -------
    Grid
        A tuple representing the dimensions (rows, cols) of the grid.
    '''
    x = math.isqrt(n)
    while n % x != 0: x -= 1
    y = n // x
    return x, y

# %% ../nbs/10_misc.ipynb 35
def grididx(pos: xypos, grid: rect) -> int:
    '''
    Calculate the linear index of an element in a `grid` given its `(row, col)` position (`pos`).

    Parameters
    ----------
    pos : XYPos
        A tuple representing the row and column position of the element in the grid.
    grid : Grid
        A tuple representing the dimensions of the grid (rows, columns).

    Returns
    -------
    int
        The linear index of the element in the grid.
    '''
    nrows, ncols = grid
    cur_r, cur_c = pos
    return cur_r * ncols + cur_c

# %% ../nbs/10_misc.ipynb 37
@overload
def pad4grid(arr: list, rows: int, cols: int) -> list: ...
@overload
def pad4grid(arr: list, n: int) -> list: ...
def pad4grid(arr: list, *args) -> list:
    '''
    Pad the list of objects to the closest grid layout that accommodates a specified number of elements.

    Parameters
    ----------
    arr : list
        The list to be padded.
    args : int
        The dimensions of the grid `(rows, cols)` or the total number of elements `n`.

    Returns
    -------
    list
        The padded list.
    '''
    rows, cols = args[0], (1 if len(args) <= 1 else args[1])
    return list(fillnone(arr, rows * cols))

# %% ../nbs/10_misc.ipynb 39
def takekeys(d: dict, keys: list | dict) -> dict:
    keys = keys or []
    if isdict(keys): keys = keys.keys()
    return {k: d.get(k, None) for k in keys if k in d}

# %% ../nbs/10_misc.ipynb 41
#| export
