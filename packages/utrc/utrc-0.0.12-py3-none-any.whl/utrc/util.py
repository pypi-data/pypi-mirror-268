# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/08_util.ipynb.

# %% auto 0
__all__ = ['extent', 'integration_steps', 'integration_space', 'zero_placeholder', 'batch_zeros', 'gauss_like']

# %% ../nbs/08_util.ipynb 6
#| export


# %% ../nbs/08_util.ipynb 8
#| export


# %% ../nbs/08_util.ipynb 11
#| export

# %% ../nbs/08_util.ipynb 13
try: import numpy as np
except ImportError: ...

try: import pandas as pd
except ImportError: ...

# %% ../nbs/08_util.ipynb 15
try: import torch
except: ...

# %% ../nbs/08_util.ipynb 17
#| export


# %% ../nbs/08_util.ipynb 19
from nchr import U1, SPACE
from nlit import MPS
from quac import strq, tensor, ptdevice, nparray
from seeder import seedall

# %% ../nbs/08_util.ipynb 21
#| export


# %% ../nbs/08_util.ipynb 23
def extent(arr: list | np.ndarray | pd.Series) -> tuple[int, int]:
    '''Find the minimum and maximum of an array, list, or Series.

    Parameters
    ----------
    arr : list | np.ndarray | pd.Series
        The array, list, or Series to find the extent of.

    Returns
    -------
    tuple[int, int]
        A tuple containing the minimum and maximum values.
    '''
    try: return min(arr), max(arr)
    except: return 0, len(arr)

# %% ../nbs/08_util.ipynb 24
def integration_steps(i: int, j: int, imin: int = 2, imax: int = 100, inum: int | None = None) -> int:
    '''Calculate the number of integration steps between two points, constrained by minimum and maximum limits, 
    or a specified fixed number.

    Parameters
    ----------
    i : int
        The starting integer index.
    j : int
        The ending integer index.
    imin : int, default: 2
        The minimum number of integration steps (default is 2).
    imax : int, default: 100
        The maximum number of integration steps (default is 100).
    inum : int | None, optional
        The fixed number of integration steps. If None, the number of steps is calculated based on `i` and `j`.

    Returns
    -------
    int
        The number of integration steps, either the fixed number (`inum`) if provided, or computed based on the constraints.

    Examples
    --------
    >>> integration_steps(0, 10)
    10
    >>> integration_steps(0, 10, imin=5, imax=7)
    7
    >>> integration_steps(0, 10, inum=5)
    5
    '''
    return inum or max(min((j) - i, imax), imin)

# %% ../nbs/08_util.ipynb 25
def integration_space(i: int, j: int, imin: int = 2, imax: int = 100, inum: int | None = None) -> nparray:
    '''Generate linearly spaced integration points between two bounds `i` and `j` with a specified number of points.

    Parameters
    ----------
    i : int
        The start point of the interval.
    j : int
        The end point of the interval.
    imin : int, default: 2
        The minimum number of points (default is 2).
    imax : int, default: 100
        The maximum number of points (default is 100).
    inum : int | None, optional
        The fixed number of points. If None, the number of points will be calculated.

    Returns
    -------
    np.ndarray
        An array of linearly spaced points between `i` and `j`.

    Examples
    --------
    >>> integration_space(0, 10)
    array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.])
    >>> integration_space(0, 10, imin=5, imax=7)
    array([ 0. ,  2. ,  4. ,  6. ,  8. , 10. ])
    >>> integration_space(0, 10, inum=5)
    array([ 0.,  2.5,  5. ,  7.5, 10. ])
    '''
    return np.linspace(i, j, integration_steps(i, j, imin, imax, inum))

# %% ../nbs/08_util.ipynb 26
def zero_placeholder(x: tensor) -> tensor:
    '''Returns a zero tensor placeholder with the same type and device as the input tensor `x`.

    Parameters
    ----------
    x : torch.Tensor
        Input tensor to replicate the properties (dtype, device).

    Returns
    -------
    torch.Tensor
        A tensor containing a single scalar zero with the same dtype and device as `x`.

    Examples
    --------
    >>> x = torch.tensor([1, 2, 3], dtype=torch.float32)
    >>> zero_placeholder(x)
    tensor(0.)
    '''
    return torch.tensor(0, dtype=x.dtype, requires_grad=True, device=x.device)

# %% ../nbs/08_util.ipynb 27
def batch_zeros(x: tensor, n: int = 1) -> tensor:
    '''
    Creates a batch of zero tensors replicating the batch size of `x`, with `n` columns.

    Parameters
    ----------
    x : torch.Tensor
        The input tensor to determine the batch size from.
    n : int, optional
        The number of zero-filled columns to return for each batch element (default is 1).

    Returns
    -------
    torch.Tensor
        A batched zero tensor with the same batch size and device as `x`, and `n` columns.

    Examples
    --------
    >>> x = torch.tensor([[1, 2], [3, 4]])
    >>> batch_zeros(x, n=3)
    tensor([[0, 0, 0],
            [0, 0, 0]])
    '''
    zero = torch.tensor([0], dtype=x.dtype, device=x.device)
    zeros = zero.repeat(x.size(0), n)
    return zeros

# %% ../nbs/08_util.ipynb 28
def gauss_like(x: tensor, scale: float = 1.) -> tensor:
    '''
    Returns a tensor sampled from a Gaussian distribution with mean 0 and standard deviation `scale`, 
    having the same size as `x`.

    Parameters
    ----------
    x : torch.Tensor
        The tensor to determine the shape and properties (dtype, device).
    scale : float, optional
        The scaling factor for the standard deviation of the Gaussian distribution (default is 1.0).

    Returns
    -------
    torch.Tensor
        A tensor of random numbers drawn from a Gaussian distribution with properties like `x`.

    Examples
    --------
    >>> x = torch.tensor([1.0, 2.0])
    >>> gauss_like(x)
    tensor([-0.4914,  2.1044])  # random
    '''
    return scale * torch.randn_like(x, requires_grad=False, dtype=x.dtype, device=x.device)

# %% ../nbs/08_util.ipynb 30
#| export
