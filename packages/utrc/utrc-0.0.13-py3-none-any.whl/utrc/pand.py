# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_pand.ipynb.

# %% auto 0
__all__ = ['is_not_named', 'drop_named_index', 'is_unnamed', 'as_categories', 'column_as_category', 'get_categories',
           'get_category_indexes', 'drop_column', 'get_group', 'extent', 'samples_per_category', 'sample_categories',
           'sample_index', 'numpy_labels']

# %% ../nbs/10_pand.ipynb 6
from enum import StrEnum, auto

# %% ../nbs/10_pand.ipynb 8
from typing import overload

# %% ../nbs/10_pand.ipynb 11
#| export

# %% ../nbs/10_pand.ipynb 13
try: import numpy as np
except: ...
try: import pandas as pd
except: ...

# %% ../nbs/10_pand.ipynb 15
#| export


# %% ../nbs/10_pand.ipynb 17
#| export


# %% ../nbs/10_pand.ipynb 19
from nlit import UNNAMED_CLN, CATEGORY, LABEL, ASTYPE, IGNORE
from chck import isdf, isstr, isnone, isnilstr
from quac import boolindex, groupkey
from etrc import LocReturn, SampleCategoriesMethod

# %% ../nbs/10_pand.ipynb 21
from .atyp import T
from .attr import _name, _index

# %% ../nbs/10_pand.ipynb 24
@overload
def is_not_named(obj: object) -> bool: ...
@overload
def is_not_named(index: pd.Index) -> bool: ...
@overload
def is_not_named(series: pd.Series) -> bool: ...
@overload
def is_not_named(df: pd.DataFrame) -> bool: ...
@overload
def is_not_named(name: str) -> bool: ...
def is_not_named(item: str) -> bool:
    '''Check if a pandas `Index`, `Series`, or `DataFrame`'s index does not have a name, its `name` is `None`, or `''`.
    
    Parameters
    ----------
    item : object, pd.Index, pd.Series, pd.DataFrame, str
        The item to check for a named or unnamed status.

    Returns
    -------
    bool
        True if the item is not named, False otherwise.
    
    Notes
    -----
    `is_not_named` has the following overloaded function signatures:
        - is_not_named(obj: object) -> bool
        - is_not_named(index: pd.Index) -> bool
        - is_not_named(series: pd.Series) -> bool
        - is_not_named(df: pd.DataFrame) -> bool
        - is_not_named(name: str) -> bool
    '''
    if isdf(item): 
        return is_not_named(_index(df))
    elif isstr(item):
        return isnone(item) or isnilstr(item)
    return isnone(_name(item))

# %% ../nbs/10_pand.ipynb 25
def drop_named_index(df: pd.DataFrame) -> pd.DataFrame:
    '''Reset index of the DataFrame if it is not named.

    Parameters
    ----------
    df : pd.DataFrame
        The DataFrame whose index to potentially drop.

    Returns
    -------
    pd.DataFrame
        DataFrame with the index dropped if it was not named.
    '''
    return df.reset_index(drop=is_not_named(df))

# %% ../nbs/10_pand.ipynb 26
@overload
def is_unnamed(obj: object, include_none: bool = True) -> bool: ...
@overload
def is_unnamed(col: str, include_none: bool = True) -> bool: ...
@overload
def is_unnamed(index: pd.Index, include_none: bool = True) -> bool: ...
@overload
def is_unnamed(series: pd.Series, include_none: bool = True) -> bool: ...
@overload
def is_unnamed(df: pd.DataFrame, include_none: bool = True) -> bool: ...
@overload
def is_unnamed(name: str, include_none: bool = True) -> bool: ...
@overload
def is_unnamed(item: str, include_none: bool = True) -> bool: ...
def is_unnamed(item: pd.DataFrame | pd.Index | str, include_none: bool = True) -> bool:
    '''Check if a column name is an unnamed/auto-generated name in a DataFrame.

    This function is useful when working with pandas DataFrames, as pandas often
    generates column names like 'Unnamed: 0' for unnamed columns when reading files.

    Parameters
    ----------
    item : pd.DataFrame | pd.Index | str
        The DataFrame whose's index should be checked. The pd.Index
        The column name to check.
        
    include_none : bool, default: True
        Whether or not `None` is considered to be unnamed.

    Returns
    -------
    bool
        True if the column name is an unnamed/auto-generated one, False otherwise.

    Examples
    --------
    >>> is_unnamed('Unnamed: 0')
    True

    >>> is_unnamed('my_column')
    False
    
    See Also
    --------
    is_not_named : Check if a pandas `Index`, `Series`, or `DataFrame`'s index does not have a name, its `name` is `None`, or `''`.
    
    Notes
    -----
    `is_unnamed` has the following overloaded function signatures:
        - is_unnamed(obj: object, include_none: bool = True) -> bool
        - is_unnamed(col: str, include_none: bool = True) -> bool
        - is_unnamed(index: pd.Index, include_none: bool = True) -> bool
        - is_unnamed(series: pd.Series, include_none: bool = True) -> bool
        - is_unnamed(df: pd.DataFrame, include_none: bool = True) -> bool
        - is_unnamed(name: str, include_none: bool = True) -> bool
    '''
    if include_none and is_not_named(item): return True
    return item.strip().casefold().startswith(UNNAMED_CLN)

# %% ../nbs/10_pand.ipynb 27
@overload
def as_categories(obj: T) -> T | pd.Categorical: ...
@overload
def as_categories(index: pd.Index) -> pd.CategoricalIndex: ...
@overload
def as_categories(series: pd.Series) -> pd.Series | pd.CategoricalIndex: ...
@overload
def as_categories(column: pd.Series) -> pd.Series | pd.CategoricalIndex: ...
@overload
def as_categories(df: pd.DataFrame) -> pd.DataFrame: ...
def as_categories(item: T | pd.Index | pd.Series | pd.DataFrame) -> T | pd.Series | pd.Categorical | pd.CategoricalIndex | pd.DataFrame:
    '''Convert the given item to pandas Categorical type if applicable.

    Parameters
    ----------
    item : T | pd.Index | pd.Series | pd.DataFrame
        The item to convert, can be a variety of pandas objects or other types.

    Returns
    -------
    T | pd.Series | pd.Categorical | pd.CategoricalIndex | pd.DataFrame
        The item converted to a Categorical type, if applicable.
        
    Notes
    -----
    `as_categories` has the following overloaded function signatures:
        - as_categories(obj: T) -> T | pd.Categorical
        - as_categories(index: pd.Index) -> pd.CategoricalIndex
        - as_categories(series: pd.Series) -> pd.Series | pd.CategoricalIndex
        - as_categories(df: pd.DataFrame) -> pd.DataFrame
    '''
    return getattr(item, ASTYPE, lambda t: item)(CATEGORY)

# %% ../nbs/10_pand.ipynb 28
def column_as_category(df: pd.DataFrame, col: str = LABEL) -> pd.Series | pd.Categorical | pd.CategoricalIndex:
    '''Retrieve a column from the DataFrame as a Categorical type.

    Parameters
    ----------
    df : pd.DataFrame
        The DataFrame from which to retrieve the column.
        
    col : str, default: 'label'
        The name of the column to retrieve.

    Returns
    -------
    pd.Series | pd.Categorical | pd.CategoricalIndex
        The specified column converted to a Categorical type.
    '''
    return as_categories(drop_named_index(df)[col])

def get_categories(df: pd.DataFrame, col: str = LABEL) -> pd.Series:
    '''Retrieve unique categories from a specified column in a DataFrame as a sorted Series.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame from which categories are to be retrieved.
    col : str, default: 'label'
        The column name from which to retrieve unique categories.

    Returns
    -------
    pd.Series
        A Series containing sorted unique categories from the specified column.
    '''
    return pd.Series(sorted(get_categorical_column(df, col).unique()), name=col)

def get_category_indexes(
    df: pd.DataFrame, col: str = LABEL, ret: LocReturn = LocReturn.bloc
) -> dict[int, pd.Index | pd.Series | boolindex]:
    '''Retrieve indexes for each category in a specified column of a DataFrame.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to process.
        
    col : str, default: 'label'
        The column name from which to retrieve categories.
        
    ret : LocReturn, default: LocReturn.bloc
        The type of indexes to return: boolean index, integer index, or default pandas index.

    Returns
    -------
    dict
        A dictionary with category codes as keys and indexes as values, 
        according to the specified return type.
    '''

    catcol = get_categorical_column(df, col)
    ccodes = catcol.cat.codes
    boolix = {c: (ccodes == c) for c in sorted(catcol.unique())}
    match ret:
        case LocReturn.bloc: return boolix
        case LocReturn.iloc: return {c: b[b == True].index for c, b in boolix.items()}
        case LocReturn.loc: return boolix
        case _: return boolix

# %% ../nbs/10_pand.ipynb 29
def drop_column(df: pd.DataFrame, col: str = LABEL) -> pd.DataFrame:
    '''Drop the specified column from a DataFrame and reset the index if it is not named.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to modify.
        
    col : str, default: 'label'
        Column name to drop.

    Returns
    -------
    pd.DataFrame
        Modified DataFrame with the specified column dropped.
    '''
    return drop_named_index(df).drop(columns=[col], errors=IGNORE)

def get_group(df: pd.DataFrame, groupby: str | tuple, group: str | tuple | groupkey) -> pd.DataFrame:
    '''Retrieve a specific group from a DataFrame grouped by the specified column(s).

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to group and retrieve from.
    
    groupby : str | tuple
        Column name(s) to group by.
    
    group : str | tuple | groupkey
        The specific group's name or key to retrieve.

    Returns
    -------
    pd.DataFrame
        The DataFrame containing only the rows belonging to the specified group.
    '''
    return drop_named_index(df).groupby(groupby, observed=False).get_group(group)

# %% ../nbs/10_pand.ipynb 31
#| export

# %% ../nbs/10_pand.ipynb 32
def extent(arr: list | np.ndarray | pd.Series) -> tuple[int, int]:
    '''Find the minimum and maximum of an array, list, or Series.

    Parameters
    ----------
    arr : list | np.ndarray | pd.Series
        The array, list, or Series to find the extent of.

    Returns
    -------
    tuple[int, int]
        A tuple containing the minimum and maximum values.
    '''
    try: return min(arr), max(arr)
    except: return 0, len(arr)

def samples_per_category(df: pd.DataFrame, groupby: str | tuple = LABEL) -> pd.Series:
    '''Calculate the number of samples per category in a DataFrame.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to process.
        
    groupby : str | tuple, default: 'label'
        Column name(s) to group by.

    Returns
    -------
    pd.Series
        A Series containing the average number of samples per category.
    '''
    return drop_named_index(df).groupby(groupby, observed=False).agg(len).mean(axis=1).astype(int)

def sample_categories(df: pd.DataFrame, groupby: str | tuple = LABEL, n: int = 10) -> np.ndarray:
    '''Sample `n` instances from each category within a DataFrame.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to sample from.
    
    groupby : str | tuple, default: 'label'
        Column name(s) to group by and sample within.
    
    n : int, default: 10
        Number of samples to draw from each category.

    Returns
    -------
    np.ndarray
        An array of the sampled instances.
    '''
    return drop_named_index(df).groupby(groupby, observed=False).sample(n)

def sample_index(df: pd.DataFrame, idx: np.ndarray | pd.Series | pd.Index, n: int = 10) -> np.ndarray:
    '''Sample `n` instances from the DataFrame using provided indexes.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to sample from.
        
    idx : np.ndarray | pd.Series | pd.Index
        Indexes to use for sampling.
        
    n : int, default: 10
        Number of samples to draw.

    Returns
    -------
    np.ndarray
        An array of the sampled instances.
    '''
    return drop_named_index(df)[idx].sample(n)

def numpy_labels(df: pd.DataFrame, col: str = LABEL, n: int = 10) -> np.ndarray:
    '''Generate a numpy array of labels for each category repeated `n` times.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to generate labels from.
        
    col : str, default: 'label'
        Column name to use for label generation.
        
    n : int, default: 10
        Number of times to repeat each label.

    Returns
    -------
    np.ndarray
        A numpy array of labels.
    '''
    cats = get_categories(df, col)
    mn, mx = extent(cats)
    arng = np.arange(mn, mx + 1, 1)
    return np.tile(arng.reshape(-1, 1), (1, n)).reshape(len(arng), -1)
