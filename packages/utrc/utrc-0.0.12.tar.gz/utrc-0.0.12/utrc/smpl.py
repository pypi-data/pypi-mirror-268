# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/20_smpl.ipynb.

# %% auto 0
__all__ = ['sample_grouped', 'categorical_sample', 'sample']

# %% ../nbs/20_smpl.ipynb 6
import random
from functools import wraps

# %% ../nbs/20_smpl.ipynb 8
from typing import Union

# %% ../nbs/20_smpl.ipynb 11
#| export

# %% ../nbs/20_smpl.ipynb 13
try: import numpy as np
except ImportError: ...

try: import pandas as pd
except ImportError: ...

# %% ../nbs/20_smpl.ipynb 15
try: import torch
except: ...

# %% ../nbs/20_smpl.ipynb 17
#| export


# %% ../nbs/20_smpl.ipynb 19
from nlit import MPS, LABEL, SAMPLES, CATEGORY, IGNORE, INDEX, NAME
from quac import groupkey, array, tensor, deviceq, dataframe, size, nums, device
from chck import notnone
from asto import asten, to
from etrc import DataFormat, BatchReturn

# %% ../nbs/20_smpl.ipynb 21
from .cons import WRAPS_ASSIGN_ANNDOCS
from .util import extent
from .misc import drop_named_index, get_categories, drop_column, groupget

# %% ../nbs/20_smpl.ipynb 24
def sample_grouped(
    df: pd.DataFrame, 
    groupby: str | tuple | tuple[groupkey, ...] = LABEL, 
    n: int = 10, 
    replace: bool = False
) -> np.ndarray:
    '''Sample `n` instances from each category within a DataFrame.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to sample from.
    
    groupby : str | tuple, default: 'label'
        Column name(s) to group by and sample within.
    
    n : int, default: 10
        Number of samples to draw from each category.
        
    replace : bool, default: False
        Whether or not to sample with replacement.
        
    Returns
    -------
    np.ndarray
        An array of the sampled instances.
    '''
    return drop_named_index(df).groupby(groupby, observed=False).sample(n, replace=replace)

# %% ../nbs/20_smpl.ipynb 25
def _categorical_sample(
    df: pd.DataFrame, 
    col: str = LABEL, 
    n: int = 10,
    replace: bool = False,  
):
    '''Sample `n` instances from each category within a DataFrame using numpy.'''
    cats = get_categories(df, col)
    ncat = len(cats)
    subs = sample_grouped(df, col, n, replace=replace)
    return np.stack(np.array_split(drop_column(subs, col).values, ncat))

# %% ../nbs/20_smpl.ipynb 26
def _categorical_labels(
    df: pd.DataFrame, 
    col: str = LABEL, 
    n: int = 10
) -> np.ndarray:
    '''Generate a numpy array of labels for each category repeated `n` times.'''
    cats = get_categories(df, col)
    mn, mx = extent(cats)
    arng = np.arange(mn, mx + 1, 1)
    return np.tile(arng.reshape(-1, 1), (1, n)).reshape(len(arng), -1)

# %% ../nbs/20_smpl.ipynb 27
def categorical_sample(
    df: pd.DataFrame, 
    col: str = LABEL, 
    n: int = 10, 
    replace: bool = False, 
    format: DataFormat = DataFormat.numpy,
    output: BatchReturn = BatchReturn.xy,
    device: str = MPS, 
) -> tuple[np.ndarray | tensor, np.ndarray | tensor]:
    '''Generate a numpy array of labels for each category repeated `n` times.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to generate labels from.
        
    col : str, default: 'label'
        Column name to use for label generation.
        
    n : int, default: 10
        Number of times to repeat each label.
        
    replace : bool, default: False
        Whether or not to sample with replacement.
        
    format : DataFormat, default: DataFormat.numpy
        The format to return the data in.
        
    output : BatchReturn, default: BatchReturn.xy
        Which part of the batch ot return.
    
    device : str | torch.device, default: 'mps'
        The device to try and put the tensor on.
    Returns
    -------
    np.ndarray | torch.tensor
        A numpy array of labels.
    '''
    x, y = None, None
    match output:
        case BatchReturn.x: 
            x = _categorical_sample(df, col, n, replace)
        case BatchReturn.y: 
            y = _categorical_labels(df, col, n)
        case BatchReturn.xy: 
            x, y = _categorical_sample(df, col, n, replace), _categorical_labels(df, col, n)
        case _: 
            x, y = _categorical_sample(df, col, n, replace), _categorical_labels(df, col, n)
        
    match format:
        case DataFormat.torch:
            if notnone(x): x = to(x, device=device)
            if notnone(y): y = to(y, device=device)
        case _: ...
        
    match output:
        case BatchReturn.x: return x
        case BatchReturn.y: return y
        case BatchReturn.xy: return (x, y)
        case _: return (x, y)

# %% ../nbs/20_smpl.ipynb 28
def sample(
    df: dataframe, 
    
    group: groupkey, 
    groupby: str = SAMPLES,
    index: str = SAMPLES, 
    set_index: bool = True,
        
    size: size = (100, ), 
    replace: bool = False,
    
    cpu: bool = False, 
    mps: bool = False, 
    cuda: bool = False, 
    device: deviceq = None,
) -> Union[array, tensor]:
    '''Samples entries from a specific group in a DataFrame, with options for setting the index, 
    sampling size, replacement, and tensor conversion.
    
    Parameters
    ----------
    df : dataframe
        The DataFrame from which to sample.
        
    group : groupkey
        The key of the group to sample from.
        
    groupby : str, default: 'sampels'
        The column name to group the DataFrame by for sampling.
        
    index : str, default: 'sampels'
        The column name to set as the index of the sample, if `set_index` is True.
        
    set_index : bool, default: True
        Determines whether to set the specified column as the index for the sampled entries.
    
    size : size, default: (100, )
        The size of the sample to draw from the group.
        
    replace : bool, default: False
        Whether to sample with replacement.
        
    cpu : bool, default: False
        Whether to convert the sample to a tensor on the CPU.
        
    mps : bool, default: False
        Whether to convert the sample to a tensor on the MPS device.
        
    cuda : bool, default: False
        Whether to convert the sample to a tensor on the CUDA device.
        
    device : ptdevice, optional
        Specifies the device to which the tensor should be moved. 
        Overrides `cpu`, `mps`, and `cuda` if not None.
        
    Returns
    -------
    Union[array, tensor]
        The sampled entries as a DataFrame or a tensor, depending on the device parameters.
    '''
    
    if index is None: index = groupby        
    sub = groupget(df, group, groupby, index, set_index)    
    
    idx = np.arange(sub.shape[0])
    sub = sub[np.random.choice(idx, size=size, replace=replace)]
        
    if any((device, cpu, mps, cuda)):
        return asten(sub, device=device, cpu=cpu, mps=mps, cuda=cuda)    
    return sub

# %% ../nbs/20_smpl.ipynb 30
#| export
