##
#   Copyright 2021 Alibaba, Inc. and its affiliates. All Rights Reserved.
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
##

# -*- coding: utf-8 -*-

from multiprocessing import Value
from typing import List, Dict, Tuple, Union, Optional
import numpy as np

DenseVectorValueType = Union[List[float], np.ndarray]

def combine_dense_and_sparse(dense_vector: DenseVectorValueType, sparse_vector: Dict[int, float], alpha: float) -> Tuple[DenseVectorValueType, Dict[int, float]]:
    """
    Using convex combination to generate hybrid vector.

    Args:
        dense_vector(DenseVectorValueType): dense vector
        sparse_vector (Dict[int, float]): sparse vector generated by encode_documents or encode_query method.
        alpha(float): float between 0 and 1, alpha=0.0 means sparse vector only, alpha=1.0 means dense vector only.

    Return:
        a tuple of dense and sparse vectors scaled by alpha as a convex combination:
        ((dense * alpha), (sparse * (1 - alpha))).
    """
    # check sparse vector format
    if not isinstance(sparse_vector, dict):
        raise TypeError("sparse_vector must be Dict[int, float]")
    for key, value in sparse_vector.items():
        if not isinstance(key, int) or not isinstance(value, float):
            raise TypeError("sparse_vector must be Dict[int, float]")
    
    # check dense vector format
    if isinstance(dense_vector, list):
        if len(dense_vector) == 0:
            raise ValueError("dense_vector must not be empty")
        if not isinstance(dense_vector[0], float):
            raise TypeError("dense_vector value type must be float")
    elif isinstance(dense_vector, np.ndarray):
        if dense_vector.ndim != 1:
            raise ValueError("dense_vector ndim must be 1")
        if not np.issubdtype(dense_vector.dtype, np.floating):
            raise TypeError("dense_vector value type must be float")
    else:
        raise TypeError("dense_vector must be List[float] or np.ndarray")

    if not isinstance(alpha, float):
        raise TypeError("alpha must be a float")

    if not 0 <= alpha <= 1:
        raise ValueError("alpha must be between 0 and 1")

    if isinstance(dense_vector, list):
        scaled_dense = [v * alpha for v in dense_vector]
    else:
        scaled_dense = dense_vector * alpha
    scaled_sparse = {key: value * (1 - alpha) for key, value in sparse_vector.items()}
    
    return scaled_dense, scaled_sparse
