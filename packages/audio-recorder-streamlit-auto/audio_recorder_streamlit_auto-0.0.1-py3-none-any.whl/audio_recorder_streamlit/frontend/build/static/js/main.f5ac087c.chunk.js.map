{"version":3,"sources":["AudioRecorder.tsx","index.tsx"],"names":["library","add","fas","AudioRecorder","StreamlitComponentBase","constructor","props","super","stream","AudioContext","window","webkitAudioContext","type","sampleRate","phrase_buffer_count","pause_buffer_count","pause_count","stage","volume","audioInput","analyser","recorder","recording","leftchannel","rightchannel","leftBuffer","rightBuffer","recordingLength","tested","getStream","navigator","mediaDevices","getUserMedia","audio","video","componentDidMount","async","this","args","delay","start","setupMic","err","console","log","startRecording","closeMic","getAudioTracks","forEach","track","stop","disconnect","writeUTFBytes","view","offset","string","lng","length","i","setUint8","charCodeAt","mergeBuffers","channelBuffer","result","Float32Array","buffer","set","interleave","leftChannel","rightChannel","inputIndex","index","input_sample_rate","context","seconds_per_buffer","Math","ceil","createGain","createMediaStreamSource","createAnalyser","connect","createScriptProcessor","destination","self","onaudioprocess","e","left","inputBuffer","getChannelData","right","reduce","a","b","getTracks","close","energy","sqrt","map","x","push","setState","color","interleaved","ArrayBuffer","DataView","setUint32","setUint16","setInt16","blob","Blob","audioUrl","URL","createObjectURL","onStop","url","render","theme","text","React","createElement","FontAwesomeIcon","icon","onClick","onClicked","style","state","size","data","arrayBuffer","json_string","JSON","stringify","Array","from","Uint8Array","Streamlit","setComponentValue","ms","Promise","resolve","setTimeout","withStreamlitConnection","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f5ac087c.chunk.js","sourcesContent":["import { library } from '@fortawesome/fontawesome-svg-core';\nimport { fas } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport React, { ReactNode } from \"react\";\nimport {\n  Streamlit,\n  StreamlitComponentBase,\n  withStreamlitConnection\n} from \"streamlit-component-lib\";\n\nlibrary.add(fas)\n\ninterface AudioRecorderState {\n  color: string\n}\n\ninterface AudioData {\n  blob: Blob\n  url: string\n  type: string\n}\n\ninterface AudioRecorderProps {\n  args: Map<string, any>\n  width: number\n  disabled: boolean\n}\n\n\nclass AudioRecorder extends StreamlitComponentBase<AudioRecorderState> {\n  public constructor(props: AudioRecorderProps) {\n    super(props)\n    this.state = { color: this.props.args[\"neutral_color\"] }\n    if(this.props.args[\"auto_start\"]) {\n      //this.onClicked();\n    }\n  }\n\n  stream: MediaStream | null = null;\n  AudioContext = window.AudioContext || window.webkitAudioContext;\n  type: string = \"audio/wav\";\n  sampleRate: number | null = null;\n  phrase_buffer_count: number | null = null;\n  pause_buffer_count: number | null = null;\n  pause_count: number = 0;\n  stage: string | null = null;\n  volume: any = null;\n  audioInput: any = null;\n  analyser: any = null;\n  recorder: any = null;\n  recording: boolean = false;\n  leftchannel: Float32Array[] = [];\n  rightchannel: Float32Array[] = [];\n  leftBuffer: Float32Array | null = null;\n  rightBuffer: Float32Array | null = null;\n  recordingLength: number = 0;\n  tested: boolean = false;\n\n  //get mic stream\n  getStream = (): Promise<MediaStream> => {\n    return navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n  };\n\n  delay(ms: number) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  componentDidMount = async() => {\n    // Automatically trigger the onClicked function on component mount\n    if(this.props.args[\"auto_start\"]) {\n      await this.delay(5000);\n      await this.start();\n    }\n  }\n\n  setupMic = async () => {\n    try {\n      window.stream = this.stream = await this.getStream();\n    } catch (err) {\n      console.log(\"Error: Issue getting mic\", err);\n    }\n\n    this.startRecording();\n  };\n\n  closeMic = () => {\n    this.stream!.getAudioTracks().forEach((track) => {\n      track.stop();\n    });\n    this.audioInput.disconnect(0);\n    this.analyser.disconnect(0);\n    this.recorder.disconnect(0);\n  };\n\n  writeUTFBytes = (view: DataView, offset: number, string: string) => {\n    let lng = string.length;\n    for (let i = 0; i < lng; i++) {\n      view.setUint8(offset + i, string.charCodeAt(i));\n    }\n  };\n\n  mergeBuffers = (channelBuffer: Float32Array[], recordingLength: number) => {\n    let result = new Float32Array(recordingLength);\n    let offset = 0;\n    let lng = channelBuffer.length;\n    for (let i = 0; i < lng; i++) {\n      let buffer = channelBuffer[i];\n      result.set(buffer, offset);\n      offset += buffer.length;\n    }\n    return result;\n  };\n\n  interleave = (leftChannel: Float32Array, rightChannel: Float32Array) => {\n    let length = leftChannel.length + rightChannel.length;\n    let result = new Float32Array(length);\n\n    let inputIndex = 0;\n\n    for (let index = 0; index < length; ) {\n      result[index++] = leftChannel[inputIndex];\n      result[index++] = rightChannel[inputIndex];\n      inputIndex++;\n    }\n    return result;\n  };\n\n  startRecording = () => {\n    let input_sample_rate = this.props.args[\"sample_rate\"];\n    if (input_sample_rate === null) {\n      this.context = new this.AudioContext();\n      this.sampleRate = this.context.sampleRate;\n    } else {\n      this.context = new this.AudioContext(\n        {\"sampleRate\": input_sample_rate}\n      );\n      this.sampleRate = input_sample_rate;\n    }\n\n    // create buffer states counts\n    let bufferSize = 2048;\n    let seconds_per_buffer = bufferSize / this.sampleRate!;\n    this.pause_buffer_count = Math.ceil(\n      this.props.args[\"pause_threshold\"] / seconds_per_buffer\n    );\n    this.pause_count = 0;\n    this.stage = \"start\";\n\n    // creates a gain node\n    this.volume = this.context.createGain();\n\n    // creates an audio node from teh microphone incoming stream\n    this.audioInput = this.context.createMediaStreamSource(this.stream);\n\n    // Create analyser\n    this.analyser = this.context.createAnalyser();\n\n    // connect audio input to the analyser\n    this.audioInput.connect(this.analyser);\n\n    // connect analyser to the volume control\n    // analyser.connect(volume);\n\n    this.recorder = this.context.createScriptProcessor(bufferSize, 2, 2);\n\n    // we connect the volume control to the processor\n    // volume.connect(recorder);\n\n    this.analyser.connect(this.recorder);\n\n    // finally connect the processor to the output\n    this.recorder.connect(this.context.destination);\n\n    const self = this;  // to reference component from inside the function\n    this.recorder.onaudioprocess = function (e: any) {\n      // Check\n      if (!self.recording) return;\n      // Do something with the data, i.e Convert this to WAV\n      let left = e.inputBuffer.getChannelData(0);\n      let right = e.inputBuffer.getChannelData(1);\n      if (!self.tested) {\n        self.tested = true;\n        // if this reduces to 0 we are not getting any sound\n        if (!left.reduce((a: number, b: number) => a + b)) {\n          console.log(\"Error: There seems to be an issue with your Mic\");\n          // clean up;\n          self.stop();\n          self.stream!.getTracks().forEach(function (track: any) {\n            track.stop();\n          });\n          self.context.close();\n        }\n      }\n      // Check energy level\n      let energy = Math.sqrt(\n        left.map((x: number) => x * x).reduce((a: number, b: number) => a + b) / left.length\n      );\n      if (self.stage === \"start\" && energy > self.props.args[\"start_threshold\"]) {\n        self.stage = \"speaking\";\n      } else if (self.stage === \"speaking\") {\n        if (energy > self.props.args[\"end_threshold\"]) {\n          self.pause_count = 0;\n        } else {\n          self.pause_count += 1;\n          if (self.pause_count > self.pause_buffer_count!) {\n            self.stop();\n          }\n        }\n      }\n      // let radius = 33.0 + Math.sqrt(1000.0 * energy);\n      // this.props.setRadius(radius.toString());\n\n      // we clone the samples\n      self.leftchannel.push(new Float32Array(left));\n      self.rightchannel.push(new Float32Array(right));\n      self.recordingLength += bufferSize;\n    };\n    // this.visualize();\n  };\n\n  start = async () => {\n    console.log(\"started\");\n    this.recording = true;\n    this.setState({\n      color: this.props.args[\"recording_color\"]\n    })\n    await this.setupMic();\n    // reset the buffers for the new recording\n    this.leftchannel.length = this.rightchannel.length = 0;\n    this.recordingLength = 0;\n  };\n\n  stop = async () => {\n    console.log(\"stopped\");\n    this.recording = false;\n    this.setState({\n      color: this.props.args[\"neutral_color\"]\n    })\n    this.closeMic();\n\n    // we flat the left and right channels down\n    this.leftBuffer = this.mergeBuffers(this.leftchannel, this.recordingLength);\n    this.rightBuffer = this.mergeBuffers(\n      this.rightchannel,\n      this.recordingLength\n    );\n    // we interleave both channels together\n    let interleaved = this.interleave(this.leftBuffer, this.rightBuffer);\n\n    ///////////// WAV Encode /////////////////\n    // from http://typedarray.org/from-microphone-to-wav-with-getusermedia-and-web-audio/\n    //\n\n    // we create our wav file\n    let buffer = new ArrayBuffer(44 + interleaved.length * 2);\n    let view = new DataView(buffer);\n\n    // RIFF chunk descriptor\n    this.writeUTFBytes(view, 0, \"RIFF\");\n    view.setUint32(4, 44 + interleaved.length * 2, true);\n    this.writeUTFBytes(view, 8, \"WAVE\");\n    // FMT sub-chunk\n    this.writeUTFBytes(view, 12, \"fmt \");\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    // stereo (2 channels)\n    view.setUint16(22, 2, true);\n    view.setUint32(24, this.sampleRate!, true);\n    view.setUint32(28, this.sampleRate! * 4, true);\n    view.setUint16(32, 4, true);\n    view.setUint16(34, 16, true);\n    // data sub-chunk\n    this.writeUTFBytes(view, 36, \"data\");\n    view.setUint32(40, interleaved.length * 2, true);\n\n    // write the PCM samples\n    let lng = interleaved.length;\n    let index = 44;\n    let volume = 1;\n    for (let i = 0; i < lng; i++) {\n      view.setInt16(index, interleaved[i] * (0x7fff * volume), true);\n      index += 2;\n    }\n\n    // our final binary blob\n    const blob = new Blob([view], { type: this.type });\n    const audioUrl = URL.createObjectURL(blob);\n\n\n    await this.onStop({\n      blob: blob,\n      url: audioUrl,\n      type: this.type,\n    });\n  };\n\n  public render = (): ReactNode => {\n    if(!this.props.args[\"invisible\"]) {\n      const { theme } = this.props\n      const text = this.props.args[\"text\"]\n\n      if (theme) {\n        // Maintain compatibility with older versions of Streamlit that don't send\n        // a theme object.\n      }\n\n      return (\n        <span>\n          {text} &nbsp;\n          <FontAwesomeIcon\n          // @ts-ignore\n          icon={this.props.args[\"icon_name\"]}\n          onClick={this.onClicked}\n          style={{color:this.state.color}}\n          size={this.props.args[\"icon_size\"]}\n          />\n        </span>\n      )\n    } else {\n      return \"\";\n    }\n  }\n\n  private onClicked = async () => {\n    if (!this.recording){\n      await this.start()\n    } else {\n      await this.stop()\n    }\n\n  }\n\n  private onStop = async (data: AudioData) => {\n    var buffer = await data.blob.arrayBuffer();\n    var json_string = JSON.stringify(Array.from(new Uint8Array(buffer)));\n    Streamlit.setComponentValue(json_string);\n  }\n\n}\n\nexport default withStreamlitConnection(AudioRecorder)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport AudioRecorder from \"./AudioRecorder\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <AudioRecorder />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}