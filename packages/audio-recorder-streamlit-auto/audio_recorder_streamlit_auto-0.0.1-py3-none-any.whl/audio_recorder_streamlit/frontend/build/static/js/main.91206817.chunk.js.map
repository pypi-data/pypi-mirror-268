{"version":3,"sources":["AudioRecorder.tsx","index.tsx"],"names":["library","add","fas","AudioRecorder","StreamlitComponentBase","constructor","props","super","stream","AudioContext","window","webkitAudioContext","type","sampleRate","phrase_buffer_count","pause_buffer_count","pause_count","stage","volume","audioInput","analyser","recorder","recording","leftchannel","rightchannel","leftBuffer","rightBuffer","recordingLength","tested","getStream","navigator","mediaDevices","getUserMedia","audio","video","setupMic","async","this","err","console","log","startRecording","closeMic","getAudioTracks","forEach","track","stop","disconnect","writeUTFBytes","view","offset","string","lng","length","i","setUint8","charCodeAt","mergeBuffers","channelBuffer","result","Float32Array","buffer","set","interleave","leftChannel","rightChannel","inputIndex","index","input_sample_rate","args","context","concat","seconds_per_buffer","Math","ceil","createGain","createMediaStreamSource","createAnalyser","connect","createScriptProcessor","destination","self","onaudioprocess","e","left","inputBuffer","getChannelData","right","reduce","a","b","getTracks","close","energy","sqrt","map","x","push","start","setState","color","interleaved","ArrayBuffer","DataView","setUint32","setUint16","setInt16","blob","Blob","audioUrl","URL","createObjectURL","onStop","url","render","theme","text","React","createElement","FontAwesomeIcon","icon","onClick","onClicked","style","state","size","data","arrayBuffer","json_string","JSON","stringify","Array","from","Uint8Array","Streamlit","setComponentValue","componentDidMount","withStreamlitConnection","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.91206817.chunk.js","sourcesContent":["import { library } from '@fortawesome/fontawesome-svg-core';\nimport { fas } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport React, { ReactNode } from \"react\";\nimport {\n  Streamlit,\n  StreamlitComponentBase,\n  withStreamlitConnection\n} from \"streamlit-component-lib\";\n\nlibrary.add(fas)\n\ninterface AudioRecorderState {\n  color: string\n}\n\ninterface AudioData {\n  blob: Blob\n  url: string\n  type: string\n}\n\ninterface AudioRecorderProps {\n  args: Map<string, any>\n  width: number\n  disabled: boolean\n}\n\n\nclass AudioRecorder extends StreamlitComponentBase<AudioRecorderState> {\n  public constructor(props: AudioRecorderProps) {\n    super(props)\n    this.state = { color: this.props.args[\"neutral_color\"] }\n    if(this.props.args[\"auto_start\"]) {\n      //this.onClicked();\n    }\n  }\n\n  stream: MediaStream | null = null;\n  AudioContext = window.AudioContext || window.webkitAudioContext;\n  type: string = \"audio/wav\";\n  sampleRate: number | null = null;\n  phrase_buffer_count: number | null = null;\n  pause_buffer_count: number | null = null;\n  pause_count: number = 0;\n  stage: string | null = null;\n  volume: any = null;\n  audioInput: any = null;\n  analyser: any = null;\n  recorder: any = null;\n  recording: boolean = false;\n  leftchannel: Float32Array[] = [];\n  rightchannel: Float32Array[] = [];\n  leftBuffer: Float32Array | null = null;\n  rightBuffer: Float32Array | null = null;\n  recordingLength: number = 0;\n  tested: boolean = false;\n\n  //get mic stream\n  getStream = (): Promise<MediaStream> => {\n    return navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n  };\n\n  componentDidMount() {\n    // Automatically trigger the onClicked function on component mount\n    if(this.props.args[\"auto_start\"]) {\n      this.onClicked();\n    }\n  }\n\n  setupMic = async () => {\n    try {\n      window.stream = this.stream = await this.getStream();\n    } catch (err) {\n      console.log(\"Error: Issue getting mic\", err);\n    }\n\n    this.startRecording();\n  };\n\n  closeMic = () => {\n    this.stream!.getAudioTracks().forEach((track) => {\n      track.stop();\n    });\n    this.audioInput.disconnect(0);\n    this.analyser.disconnect(0);\n    this.recorder.disconnect(0);\n  };\n\n  writeUTFBytes = (view: DataView, offset: number, string: string) => {\n    let lng = string.length;\n    for (let i = 0; i < lng; i++) {\n      view.setUint8(offset + i, string.charCodeAt(i));\n    }\n  };\n\n  mergeBuffers = (channelBuffer: Float32Array[], recordingLength: number) => {\n    let result = new Float32Array(recordingLength);\n    let offset = 0;\n    let lng = channelBuffer.length;\n    for (let i = 0; i < lng; i++) {\n      let buffer = channelBuffer[i];\n      result.set(buffer, offset);\n      offset += buffer.length;\n    }\n    return result;\n  };\n\n  interleave = (leftChannel: Float32Array, rightChannel: Float32Array) => {\n    let length = leftChannel.length + rightChannel.length;\n    let result = new Float32Array(length);\n\n    let inputIndex = 0;\n\n    for (let index = 0; index < length; ) {\n      result[index++] = leftChannel[inputIndex];\n      result[index++] = rightChannel[inputIndex];\n      inputIndex++;\n    }\n    return result;\n  };\n\n  startRecording = () => {\n    let input_sample_rate = this.props.args[\"sample_rate\"];\n    if (input_sample_rate === null) {\n      this.context = new this.AudioContext();\n      this.sampleRate = this.context.sampleRate;\n    } else {\n      this.context = new this.AudioContext(\n        {\"sampleRate\": input_sample_rate}\n      );\n      this.sampleRate = input_sample_rate;\n    }\n    console.log(`Sample rate ${this.sampleRate}Hz`);\n\n    // create buffer states counts\n    let bufferSize = 2048;\n    let seconds_per_buffer = bufferSize / this.sampleRate!;\n    this.pause_buffer_count = Math.ceil(\n      this.props.args[\"pause_threshold\"] / seconds_per_buffer\n    );\n    this.pause_count = 0;\n    this.stage = \"start\";\n\n    // creates a gain node\n    this.volume = this.context.createGain();\n\n    // creates an audio node from teh microphone incoming stream\n    this.audioInput = this.context.createMediaStreamSource(this.stream);\n\n    // Create analyser\n    this.analyser = this.context.createAnalyser();\n\n    // connect audio input to the analyser\n    this.audioInput.connect(this.analyser);\n\n    // connect analyser to the volume control\n    // analyser.connect(volume);\n\n    this.recorder = this.context.createScriptProcessor(bufferSize, 2, 2);\n\n    // we connect the volume control to the processor\n    // volume.connect(recorder);\n\n    this.analyser.connect(this.recorder);\n\n    // finally connect the processor to the output\n    this.recorder.connect(this.context.destination);\n\n    const self = this;  // to reference component from inside the function\n    this.recorder.onaudioprocess = function (e: any) {\n      // Check\n      if (!self.recording) return;\n      // Do something with the data, i.e Convert this to WAV\n      let left = e.inputBuffer.getChannelData(0);\n      let right = e.inputBuffer.getChannelData(1);\n      if (!self.tested) {\n        self.tested = true;\n        // if this reduces to 0 we are not getting any sound\n        if (!left.reduce((a: number, b: number) => a + b)) {\n          console.log(\"Error: There seems to be an issue with your Mic\");\n          // clean up;\n          self.stop();\n          self.stream!.getTracks().forEach(function (track: any) {\n            track.stop();\n          });\n          self.context.close();\n        }\n      }\n      // Check energy level\n      let energy = Math.sqrt(\n        left.map((x: number) => x * x).reduce((a: number, b: number) => a + b) / left.length\n      );\n      if (self.stage === \"start\" && energy > self.props.args[\"start_threshold\"]) {\n        self.stage = \"speaking\";\n      } else if (self.stage === \"speaking\") {\n        if (energy > self.props.args[\"end_threshold\"]) {\n          self.pause_count = 0;\n        } else {\n          self.pause_count += 1;\n          if (self.pause_count > self.pause_buffer_count!) {\n            self.stop();\n          }\n        }\n      }\n      // let radius = 33.0 + Math.sqrt(1000.0 * energy);\n      // this.props.setRadius(radius.toString());\n\n      // we clone the samples\n      self.leftchannel.push(new Float32Array(left));\n      self.rightchannel.push(new Float32Array(right));\n      self.recordingLength += bufferSize;\n    };\n    // this.visualize();\n  };\n\n  start = async () => {\n    this.recording = true;\n    this.setState({\n      color: this.props.args[\"recording_color\"]\n    })\n    await this.setupMic();\n    // reset the buffers for the new recording\n    this.leftchannel.length = this.rightchannel.length = 0;\n    this.recordingLength = 0;\n  };\n\n  stop = async () => {\n    this.recording = false;\n    this.setState({\n      color: this.props.args[\"neutral_color\"]\n    })\n    this.closeMic();\n    console.log(this.recordingLength);\n\n    // we flat the left and right channels down\n    this.leftBuffer = this.mergeBuffers(this.leftchannel, this.recordingLength);\n    this.rightBuffer = this.mergeBuffers(\n      this.rightchannel,\n      this.recordingLength\n    );\n    // we interleave both channels together\n    let interleaved = this.interleave(this.leftBuffer, this.rightBuffer);\n\n    ///////////// WAV Encode /////////////////\n    // from http://typedarray.org/from-microphone-to-wav-with-getusermedia-and-web-audio/\n    //\n\n    // we create our wav file\n    let buffer = new ArrayBuffer(44 + interleaved.length * 2);\n    let view = new DataView(buffer);\n\n    // RIFF chunk descriptor\n    this.writeUTFBytes(view, 0, \"RIFF\");\n    view.setUint32(4, 44 + interleaved.length * 2, true);\n    this.writeUTFBytes(view, 8, \"WAVE\");\n    // FMT sub-chunk\n    this.writeUTFBytes(view, 12, \"fmt \");\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    // stereo (2 channels)\n    view.setUint16(22, 2, true);\n    view.setUint32(24, this.sampleRate!, true);\n    view.setUint32(28, this.sampleRate! * 4, true);\n    view.setUint16(32, 4, true);\n    view.setUint16(34, 16, true);\n    // data sub-chunk\n    this.writeUTFBytes(view, 36, \"data\");\n    view.setUint32(40, interleaved.length * 2, true);\n\n    // write the PCM samples\n    let lng = interleaved.length;\n    let index = 44;\n    let volume = 1;\n    for (let i = 0; i < lng; i++) {\n      view.setInt16(index, interleaved[i] * (0x7fff * volume), true);\n      index += 2;\n    }\n\n    // our final binary blob\n    const blob = new Blob([view], { type: this.type });\n    const audioUrl = URL.createObjectURL(blob);\n\n\n    await this.onStop({\n      blob: blob,\n      url: audioUrl,\n      type: this.type,\n    });\n  };\n\n  public render = (): ReactNode => {\n    if(!this.props.args[\"invisible\"]) {\n      const { theme } = this.props\n      const text = this.props.args[\"text\"]\n\n      if (theme) {\n        // Maintain compatibility with older versions of Streamlit that don't send\n        // a theme object.\n      }\n\n      return (\n        <span>\n          {text} &nbsp;\n          <FontAwesomeIcon\n          // @ts-ignore\n          icon={this.props.args[\"icon_name\"]}\n          onClick={this.onClicked}\n          style={{color:this.state.color}}\n          size={this.props.args[\"icon_size\"]}\n          />\n        </span>\n      )\n    } else {\n      return \"\";\n    }\n  }\n\n  private onClicked = async () => {\n    if (!this.recording){\n      await this.start()\n    } else {\n      await this.stop()\n    }\n\n  }\n\n  private onStop = async (data: AudioData) => {\n    var buffer = await data.blob.arrayBuffer();\n    var json_string = JSON.stringify(Array.from(new Uint8Array(buffer)));\n    Streamlit.setComponentValue(json_string);\n  }\n\n}\n\nexport default withStreamlitConnection(AudioRecorder)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport AudioRecorder from \"./AudioRecorder\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <AudioRecorder />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}