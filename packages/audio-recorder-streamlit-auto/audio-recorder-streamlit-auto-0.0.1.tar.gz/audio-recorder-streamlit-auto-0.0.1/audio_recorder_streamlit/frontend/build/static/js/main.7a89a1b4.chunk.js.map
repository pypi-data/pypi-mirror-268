{"version":3,"sources":["AudioRecorder.tsx","index.tsx"],"names":["library","add","fas","AudioRecorder","StreamlitComponentBase","constructor","props","super","stream","AudioContext","window","webkitAudioContext","type","sampleRate","phrase_buffer_count","pause_buffer_count","pause_count","stage","volume","audioInput","analyser","recorder","recording","leftchannel","rightchannel","leftBuffer","rightBuffer","recordingLength","getStream","navigator","mediaDevices","getUserMedia","audio","video","componentDidMount","async","this","args","start","setupMic","err","console","log","startRecording","closeMic","getAudioTracks","forEach","track","stop","disconnect","writeUTFBytes","view","offset","string","lng","length","i","setUint8","charCodeAt","mergeBuffers","channelBuffer","result","Float32Array","buffer","set","interleave","leftChannel","rightChannel","inputIndex","index","input_sample_rate","context","seconds_per_buffer","Math","ceil","createGain","createMediaStreamSource","createAnalyser","connect","createScriptProcessor","destination","self","onaudioprocess","e","left","inputBuffer","getChannelData","right","energy","sqrt","map","x","reduce","a","b","push","setState","color","interleaved","ArrayBuffer","DataView","setUint32","setUint16","setInt16","blob","Blob","audioUrl","URL","createObjectURL","onStop","url","render","theme","text","React","createElement","FontAwesomeIcon","icon","onClick","onClicked","style","state","size","data","arrayBuffer","json_string","JSON","stringify","Array","from","Uint8Array","Streamlit","setComponentValue","withStreamlitConnection","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.7a89a1b4.chunk.js","sourcesContent":["import { library } from '@fortawesome/fontawesome-svg-core';\nimport { fas } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport React, { ReactNode } from \"react\";\nimport {\n  Streamlit,\n  StreamlitComponentBase,\n  withStreamlitConnection\n} from \"streamlit-component-lib\";\n\nlibrary.add(fas)\n\ninterface AudioRecorderState {\n  color: string\n}\n\ninterface AudioData {\n  blob: Blob\n  url: string\n  type: string\n}\n\ninterface AudioRecorderProps {\n  args: Map<string, any>\n  width: number\n  disabled: boolean\n}\n\n\nclass AudioRecorder extends StreamlitComponentBase<AudioRecorderState> {\n  public constructor(props: AudioRecorderProps) {\n    super(props)\n    this.state = { color: this.props.args[\"neutral_color\"] }\n  }\n\n  stream: MediaStream | null = null;\n  AudioContext = window.AudioContext || window.webkitAudioContext;\n  type: string = \"audio/wav\";\n  sampleRate: number | null = null;\n  phrase_buffer_count: number | null = null;\n  pause_buffer_count: number | null = null;\n  pause_count: number = 0;\n  stage: string | null = null;\n  volume: any = null;\n  audioInput: any = null;\n  analyser: any = null;\n  recorder: any = null;\n  recording: boolean = false;\n  leftchannel: Float32Array[] = [];\n  rightchannel: Float32Array[] = [];\n  leftBuffer: Float32Array | null = null;\n  rightBuffer: Float32Array | null = null;\n  recordingLength: number = 0;\n\n  //get mic stream\n  getStream = (): Promise<MediaStream> => {\n    return navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n  };\n\n  componentDidMount = async() => {\n    // Automatically trigger the onClicked function on component mount\n    if(this.props.args[\"auto_start\"]) {\n      await this.start();\n    }\n  }\n\n  setupMic = async () => {\n    try {\n      window.stream = this.stream = await this.getStream();\n    } catch (err) {\n      console.log(\"Error: Issue getting mic\", err);\n    }\n\n    this.startRecording();\n  };\n\n  closeMic = () => {\n    this.stream!.getAudioTracks().forEach((track) => {\n      track.stop();\n    });\n    this.audioInput.disconnect(0);\n    this.analyser.disconnect(0);\n    this.recorder.disconnect(0);\n  };\n\n  writeUTFBytes = (view: DataView, offset: number, string: string) => {\n    let lng = string.length;\n    for (let i = 0; i < lng; i++) {\n      view.setUint8(offset + i, string.charCodeAt(i));\n    }\n  };\n\n  mergeBuffers = (channelBuffer: Float32Array[], recordingLength: number) => {\n    let result = new Float32Array(recordingLength);\n    let offset = 0;\n    let lng = channelBuffer.length;\n    for (let i = 0; i < lng; i++) {\n      let buffer = channelBuffer[i];\n      result.set(buffer, offset);\n      offset += buffer.length;\n    }\n    return result;\n  };\n\n  interleave = (leftChannel: Float32Array, rightChannel: Float32Array) => {\n    let length = leftChannel.length + rightChannel.length;\n    let result = new Float32Array(length);\n\n    let inputIndex = 0;\n\n    for (let index = 0; index < length; ) {\n      result[index++] = leftChannel[inputIndex];\n      result[index++] = rightChannel[inputIndex];\n      inputIndex++;\n    }\n    return result;\n  };\n\n  startRecording = () => {\n    let input_sample_rate = this.props.args[\"sample_rate\"];\n    if (input_sample_rate === null) {\n      this.context = new this.AudioContext();\n      this.sampleRate = this.context.sampleRate;\n    } else {\n      this.context = new this.AudioContext(\n        {\"sampleRate\": input_sample_rate}\n      );\n      this.sampleRate = input_sample_rate;\n    }\n\n    // create buffer states counts\n    let bufferSize = 2048;\n    let seconds_per_buffer = bufferSize / this.sampleRate!;\n    this.pause_buffer_count = Math.ceil(\n      this.props.args[\"pause_threshold\"] / seconds_per_buffer\n    );\n    this.pause_count = 0;\n    this.stage = \"start\";\n\n    // creates a gain node\n    this.volume = this.context.createGain();\n\n    // creates an audio node from teh microphone incoming stream\n    this.audioInput = this.context.createMediaStreamSource(this.stream);\n\n    // Create analyser\n    this.analyser = this.context.createAnalyser();\n\n    // connect audio input to the analyser\n    this.audioInput.connect(this.analyser);\n\n    // connect analyser to the volume control\n    // analyser.connect(volume);\n\n    this.recorder = this.context.createScriptProcessor(bufferSize, 2, 2);\n\n    // we connect the volume control to the processor\n    // volume.connect(recorder);\n\n    this.analyser.connect(this.recorder);\n\n    // finally connect the processor to the output\n    this.recorder.connect(this.context.destination);\n\n    const self = this;  // to reference component from inside the function\n    this.recorder.onaudioprocess = function (e: any) {\n      // Check\n      if (!self.recording) return;\n      // Do something with the data, i.e Convert this to WAV\n      let left = e.inputBuffer.getChannelData(0);\n      let right = e.inputBuffer.getChannelData(1);\n      // Check energy level\n      let energy = Math.sqrt(\n        left.map((x: number) => x * x).reduce((a: number, b: number) => a + b) / left.length\n      );\n      if (self.stage === \"start\" && energy > self.props.args[\"start_threshold\"]) {\n        self.stage = \"speaking\";\n      } else if (self.stage === \"speaking\") {\n        if (energy > self.props.args[\"end_threshold\"]) {\n          self.pause_count = 0;\n        } else {\n          self.pause_count += 1;\n          if (self.pause_count > self.pause_buffer_count!) {\n            self.stop();\n          }\n        }\n      }\n      // let radius = 33.0 + Math.sqrt(1000.0 * energy);\n      // this.props.setRadius(radius.toString());\n\n      // we clone the samples\n      self.leftchannel.push(new Float32Array(left));\n      self.rightchannel.push(new Float32Array(right));\n      self.recordingLength += bufferSize;\n    };\n    // this.visualize();\n  };\n\n  start = async () => {\n    console.log(\"started\");\n    this.recording = true;\n    this.setState({\n      color: this.props.args[\"recording_color\"]\n    })\n    await this.setupMic();\n    // reset the buffers for the new recording\n    this.leftchannel.length = this.rightchannel.length = 0;\n    this.recordingLength = 0;\n  };\n\n  stop = async () => {\n    console.log(\"stopped\");\n    this.recording = false;\n    this.setState({\n      color: this.props.args[\"neutral_color\"]\n    })\n    this.closeMic();\n\n    // we flat the left and right channels down\n    this.leftBuffer = this.mergeBuffers(this.leftchannel, this.recordingLength);\n    this.rightBuffer = this.mergeBuffers(\n      this.rightchannel,\n      this.recordingLength\n    );\n    // we interleave both channels together\n    let interleaved = this.interleave(this.leftBuffer, this.rightBuffer);\n\n    ///////////// WAV Encode /////////////////\n    // from http://typedarray.org/from-microphone-to-wav-with-getusermedia-and-web-audio/\n    //\n\n    // we create our wav file\n    let buffer = new ArrayBuffer(44 + interleaved.length * 2);\n    let view = new DataView(buffer);\n\n    // RIFF chunk descriptor\n    this.writeUTFBytes(view, 0, \"RIFF\");\n    view.setUint32(4, 44 + interleaved.length * 2, true);\n    this.writeUTFBytes(view, 8, \"WAVE\");\n    // FMT sub-chunk\n    this.writeUTFBytes(view, 12, \"fmt \");\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    // stereo (2 channels)\n    view.setUint16(22, 2, true);\n    view.setUint32(24, this.sampleRate!, true);\n    view.setUint32(28, this.sampleRate! * 4, true);\n    view.setUint16(32, 4, true);\n    view.setUint16(34, 16, true);\n    // data sub-chunk\n    this.writeUTFBytes(view, 36, \"data\");\n    view.setUint32(40, interleaved.length * 2, true);\n\n    // write the PCM samples\n    let lng = interleaved.length;\n    let index = 44;\n    let volume = 1;\n    for (let i = 0; i < lng; i++) {\n      view.setInt16(index, interleaved[i] * (0x7fff * volume), true);\n      index += 2;\n    }\n\n    // our final binary blob\n    const blob = new Blob([view], { type: this.type });\n    const audioUrl = URL.createObjectURL(blob);\n\n\n    await this.onStop({\n      blob: blob,\n      url: audioUrl,\n      type: this.type,\n    });\n  };\n\n  public render = (): ReactNode => {\n    if(!this.props.args[\"invisible\"]) {\n      const { theme } = this.props\n      const text = this.props.args[\"text\"]\n\n      if (theme) {\n        // Maintain compatibility with older versions of Streamlit that don't send\n        // a theme object.\n      }\n\n      return (\n        <span>\n          {text} &nbsp;\n          <FontAwesomeIcon\n          // @ts-ignore\n          icon={this.props.args[\"icon_name\"]}\n          onClick={this.onClicked}\n          style={{color:this.state.color}}\n          size={this.props.args[\"icon_size\"]}\n          />\n        </span>\n      )\n    } else {\n      return \"\";\n    }\n  }\n\n  private onClicked = async () => {\n    if (!this.recording){\n      await this.start()\n    } else {\n      await this.stop()\n    }\n\n  }\n\n  private onStop = async (data: AudioData) => {\n    var buffer = await data.blob.arrayBuffer();\n    var json_string = JSON.stringify(Array.from(new Uint8Array(buffer)));\n    Streamlit.setComponentValue(json_string);\n  }\n\n}\n\nexport default withStreamlitConnection(AudioRecorder)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport AudioRecorder from \"./AudioRecorder\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <AudioRecorder />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}