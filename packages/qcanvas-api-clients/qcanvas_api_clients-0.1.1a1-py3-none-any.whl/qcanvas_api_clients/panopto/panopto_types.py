# generated by datamodel-codegen:
#   filename:  panoptoApi.yaml
#   timestamp: 2024-04-19T08:16:34+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, Field


class HttpRequestMessage(BaseModel):
    pass


class ExternalProviderType(Enum):
    zoom = 'Zoom'
    hive = 'Hive'
    kollective = 'Kollective'
    webex = 'Webex'
    teams_tenant = 'TeamsTenant'


class FindImportEligibilityAndProvisionMeetingFolderForUserDto(BaseModel):
    pass


class CreateSessionForSessionGroupIdAndUserIdDto(BaseModel):
    pass


class ProvisionExternalContextForSessionByExternalProviderWithPublicIdDto(BaseModel):
    pass


class CreateMeetingImportStreamDto(BaseModel):
    pass


class CreateZoomImportEditsByProviderDto(BaseModel):
    pass


class GetMappedUserIdsByEmailDto(BaseModel):
    pass


class AddMeetingParticipantsForSessionDto(BaseModel):
    pass


class CreateIntegrationMediaImportJobDto(BaseModel):
    pass


class CreateCustomThumbnailFromUploadDto(BaseModel):
    pass


class BatchAddCommentThreadsToSessionDto(BaseModel):
    pass


class APIErrorInternal(BaseModel):
    error_code: Optional[str] = Field(
        None, alias='ErrorCode', description='Internal error code'
    )
    message: Optional[str] = Field(None, alias='Message')
    success: bool = Field(
        ...,
        alias='Success',
        description='If true the call succeed and this is a partial failure (or warning). If false the call failed overall',
    )
    error_source: Optional[str] = Field(
        None,
        alias='ErrorSource',
        description='Unique identifier of what caused this error',
    )


class RemoteRecorderRegistrationRequest(BaseModel):
    machine_unique_identifier: Optional[str] = Field(
        None,
        alias='MachineUniqueIdentifier',
        description='Static, non-changing value uniquely identifing this remote recorder',
    )
    recorder_version: Optional[str] = Field(
        None,
        alias='RecorderVersion',
        description='Must be in the format of "Vendor.Product.Major.Minor.Servicing"',
    )
    recorder_build: Optional[str] = Field(
        None,
        alias='RecorderBuild',
        description='Vendor specfic build version. Format is up to the vendor but must be less than 255 characters',
    )
    capabilities: Optional[List[str]] = Field(
        None,
        alias='Capabilities',
        description='Capabilities of this recorder. Options include: screencapture, slidecapture, highlightmousecursor, capturesystemaudio, 1080p, devicetemplates',
    )
    description: Optional[str] = Field(
        None,
        alias='Description',
        description='Description of this remote recorder - the name presented to users',
    )


class RemoteRecorderConfiguration(BaseModel):
    primary_video_device: Optional[str] = Field(None, alias='PrimaryVideoDevice')
    primary_audio_device: Optional[str] = Field(None, alias='PrimaryAudioDevice')
    devices_to_ignore: Optional[List[str]] = Field(None, alias='DevicesToIgnore')
    devices_to_capture: Optional[List[str]] = Field(None, alias='DevicesToCapture')
    capture_screen: bool = Field(..., alias='CaptureScreen')
    capture_slides: bool = Field(..., alias='CaptureSlides')
    capture_system_audio: bool = Field(..., alias='CaptureSystemAudio')
    highlight_mouse_cursor: bool = Field(..., alias='HighlightMouseCursor')


class LiveMonitoringMode(Enum):
    disabled = 'Disabled'
    web_rtc_primary_audio = 'WebRtcPrimaryAudio'


class QualitySettings(BaseModel):
    audio_bitrate: int = Field(..., alias='AudioBitrate')
    framerate: int = Field(..., alias='Framerate')
    multiple_bitrate_count: int = Field(..., alias='MultipleBitrateCount')
    pixel_count: int = Field(..., alias='PixelCount')
    video_bitrate: int = Field(..., alias='VideoBitrate')


class RemoteRecorderAudioHistogramType(Enum):
    automatic = 'Automatic'
    always_stereo_histograms = 'AlwaysStereoHistograms'
    always_mono_histograms = 'AlwaysMonoHistograms'


class RemoteRecorderState(Enum):
    stopped = 'Stopped'
    previewing = 'Previewing'
    recording = 'Recording'
    paused = 'Paused'
    faulted = 'Faulted'
    disconnected = 'Disconnected'
    recorder_running = 'RecorderRunning'


class DeviceType(Enum):
    unknown = 'Unknown'
    audio = 'Audio'
    video = 'Video'
    audio_video = 'AudioVideo'


class DeviceThumbnailFormat(Enum):
    none = 'None'
    audio_hist = 'AudioHist'
    video_jpeg = 'VideoJpeg'
    audio_hist2_channel = 'AudioHist2Channel'


class RemoteRecorderScheduledRecording(BaseModel):
    id: Optional[str] = Field(None, alias='Id')
    session_id: str = Field(..., alias='SessionId')
    session_name: Optional[str] = Field(None, alias='SessionName')
    folder_id: str = Field(..., alias='FolderId')
    folder_name: Optional[str] = Field(None, alias='FolderName')
    user_id: Optional[str] = Field(None, alias='UserId')
    start_time: float = Field(..., alias='StartTime')
    end_time: float = Field(..., alias='EndTime')
    is_broadcast: bool = Field(..., alias='IsBroadcast')
    suppress_primary_devices: bool = Field(..., alias='SuppressPrimaryDevices')
    suppress_secondary_devices: bool = Field(..., alias='SuppressSecondaryDevices')
    primary_quality_settings: Optional[QualitySettings] = Field(
        None, alias='PrimaryQualitySettings'
    )
    secondary_quality_settings: Optional[QualitySettings] = Field(
        None, alias='SecondaryQualitySettings'
    )
    configuration: Optional[RemoteRecorderConfiguration] = Field(
        None, alias='Configuration'
    )


class RemoteRecorderErrorSeverity(Enum):
    invalid = 'Invalid'
    critical = 'Critical'
    error = 'Error'
    warning = 'Warning'


class RemoteRecorderErrorType(Enum):
    invalid = 'Invalid'
    general = 'General'
    device = 'Device'
    network = 'Network'
    storage = 'Storage'


class RemoteRecorderPauseRecordingRequest(BaseModel):
    pause_recording_time: float = Field(
        ...,
        alias='PauseRecordingTime',
        description='Pause recording time in UTC file time seconds',
    )


class RemoteRecorderResumeRecordingRequest(BaseModel):
    resume_recording_time: float = Field(
        ...,
        alias='ResumeRecordingTime',
        description='Resume recording time in UTC file time seconds',
    )


class RemoteRecorderURLType(Enum):
    management = 'Management'
    primary_preview = 'PrimaryPreview'
    secondary_preview = 'SecondaryPreview'
    support = 'Support'
    secondary_preview2 = 'SecondaryPreview2'
    secondary_preview3 = 'SecondaryPreview3'
    secondary_preview4 = 'SecondaryPreview4'


class WebRtcConnectOperationType(Enum):
    unknown = 'Unknown'
    initialize = 'Initialize'


class WebRtcDisconnectOperationType(Enum):
    unknown = 'Unknown'
    destroy = 'Destroy'


class WebRtcEventType(Enum):
    unknown = 'Unknown'
    ice_candidate = 'IceCandidate'
    sdp_answer = 'SdpAnswer'
    temporary_failure = 'TemporaryFailure'
    permanent_failure = 'PermanentFailure'


class WebRtcIceCandidate(BaseModel):
    candidate: Optional[str] = Field(None, alias='Candidate')
    index: int = Field(..., alias='Index')


class WebRtcSdpOfferPostData(BaseModel):
    session_description: Optional[str] = Field(
        None,
        alias='SessionDescription',
        description='The session description document, as defined by the Session Description Protocol (SDP) standard.',
    )


class BasicFolder(BaseModel):
    id: Optional[str] = Field(None, alias='Id')
    name: Optional[str] = Field(None, alias='Name')


class FolderUrls(BaseModel):
    folder_url: Optional[str] = Field(
        None, alias='FolderUrl', description='The URL to open this folder in Panopto'
    )
    embed_url: Optional[str] = Field(
        None,
        alias='EmbedUrl',
        description='The URL to an embedded version of this folder',
    )
    share_settings_url: Optional[str] = Field(
        None,
        alias='ShareSettingsUrl',
        description='The URL to change how this folder is shared. May be blank if permission is not granted.',
    )


class FolderSortFields(Enum):
    name = 'Name'
    relevance = 'Relevance'


class SortOrder(Enum):
    asc = 'Asc'
    desc = 'Desc'


class User(BaseModel):
    id: str = Field(..., alias='Id', description='The id of the user.')
    username: Optional[str] = Field(
        None, alias='Username', description='The username for this user.'
    )


class SessionUrls(BaseModel):
    viewer_url: Optional[str] = Field(
        None, alias='ViewerUrl', description='The URL to view this session in Panopto'
    )
    embed_url: Optional[str] = Field(
        None,
        alias='EmbedUrl',
        description='The URL to an embedded version of this session',
    )
    share_settings_url: Optional[str] = Field(None, alias='ShareSettingsUrl')
    download_url: Optional[str] = Field(
        None,
        alias='DownloadUrl',
        description='The URL to download this session. This URL is intended for one-time download only, and is not appropriate for direct streaming or playback. May be blank if not allowed.',
    )
    caption_download_url: Optional[str] = Field(
        None,
        alias='CaptionDownloadUrl',
        description='The URL to download captions for this session, if available.',
    )
    editor_url: Optional[str] = Field(
        None,
        alias='EditorUrl',
        description='The URL to edit this session in Panopto, if you are a creator.',
    )
    thumbnail_url: Optional[str] = Field(
        None,
        alias='ThumbnailUrl',
        description='The URL to retrieve the thumbnail for this session',
    )


class SearchResultContext(BaseModel):
    text: Optional[str] = Field(None, alias='Text')
    time: Optional[float] = Field(None, alias='Time')
    thumbnail_url: Optional[str] = Field(None, alias='ThumbnailUrl')


class SessionSortFields(Enum):
    name = 'Name'
    created_date = 'CreatedDate'
    relevance = 'Relevance'


class PlaylistUrls(BaseModel):
    viewer_url: Optional[str] = Field(
        None, alias='ViewerUrl', description='The URL to view this playlist in Panopto'
    )
    embed_url: Optional[str] = Field(
        None,
        alias='EmbedUrl',
        description='The URL to an embedded version of this playlist',
    )
    thumbnail_url: Optional[str] = Field(
        None,
        alias='ThumbnailUrl',
        description='The URL to retrieve the thumbnail for this playlist',
    )


class ModelBaseOfGuid(BaseModel):
    id: Optional[str] = Field(None, alias='Id')
    name: Optional[str] = Field(None, alias='Name')


class PlaylistSortFields(Enum):
    name = 'Name'
    created_date = 'CreatedDate'
    relevance = 'Relevance'


class AccessLevel(Enum):
    restricted = 'Restricted'
    organization_unlisted = 'OrganizationUnlisted'
    organization = 'Organization'
    public_unlisted = 'PublicUnlisted'
    public = 'Public'


class PrincipalType(Enum):
    user = 'User'
    group = 'Group'


class Role(BaseModel):
    id: Optional[str] = Field(
        None, alias='Id', description='The unique id that identifies the role.'
    )
    name: Optional[str] = Field(
        None, alias='Name', description='The name of this role.'
    )


class BuiltInRoleType(Enum):
    none = 'None'
    viewer = 'Viewer'
    creator = 'Creator'
    publisher = 'Publisher'


class PermissionDelete(BaseModel):
    role_id: Optional[str] = Field(
        None,
        alias='RoleId',
        description='Id of the role to remove from the user or group. Required when RoleType is null or None.',
    )
    role_type: Optional[BuiltInRoleType] = Field(None, alias='RoleType')
    principal_id: str = Field(
        ...,
        alias='PrincipalId',
        description='Id of the user or group from which the role is being removed.',
    )
    principal_type: PrincipalType = Field(..., alias='PrincipalType')


class FolderCreate(BaseModel):
    name: Optional[str] = Field(
        None, alias='Name', description='The name of the new folder.'
    )
    description: Optional[str] = Field(
        None, alias='Description', description='The description of the new folder.'
    )
    parent: Optional[str] = Field(
        None,
        alias='Parent',
        description='Optional Id of the parent folder to create this under. The folder must already exist, and you must have create permission on the target folder.',
    )


class FolderUpdate(BaseModel):
    name: Optional[str] = Field(
        None, alias='Name', description='The new name for the folder.'
    )
    description: Optional[str] = Field(
        None, alias='Description', description='The new description for the folder.'
    )
    parent: Optional[str] = Field(
        None,
        alias='Parent',
        description='The Id of the folder to move this to. The folder must already exist, and you must have create permission on the target folder.\nTo move to a top level folder, set this to "00000000-0000-0000-0000-000000000000"',
    )


class Group(ModelBaseOfGuid):
    pass


class PlaylistUpdate(BaseModel):
    name: Optional[str] = Field(
        None, alias='Name', description='The new name for the playlist.'
    )
    description: Optional[str] = Field(
        None, alias='Description', description='The new description for the playlist.'
    )
    folder: Optional[str] = Field(
        None,
        alias='Folder',
        description='The id of the folder to move this playlist to.',
    )


class PlaylistSessionSortFields(Enum):
    name = 'Name'
    created_date = 'CreatedDate'
    relevance = 'Relevance'
    order = 'Order'


class PlaylistCreate(BaseModel):
    name: Optional[str] = Field(
        None, alias='Name', description='The name of the playlist.'
    )
    description: Optional[str] = Field(
        None,
        alias='Description',
        description='An optional description for the playlist.',
    )
    folder_id: str = Field(
        ..., alias='FolderId', description='The folder to add this playlist to.'
    )
    sessions: Optional[List[str]] = Field(
        None,
        alias='Sessions',
        description='A list of session IDs to add to this playlist. They will be added in order.',
    )


class PlaylistAddSession(BaseModel):
    session_id: str = Field(
        ...,
        alias='SessionId',
        description='The id of the session to add to this playlist.',
    )
    index: Optional[int] = Field(
        None,
        alias='Index',
        description='The index to insert the item at (starting with 0 as the beginning of the list). If this is not specified, the session will be added to the end.',
    )


class RemoteRecorder(BaseModel):
    id: Optional[str] = Field(None, alias='Id')
    name: Optional[str] = Field(None, alias='Name')
    state: RemoteRecorderState = Field(..., alias='State')
    default_recording_folder: Optional[BasicFolder] = Field(
        None, alias='DefaultRecordingFolder'
    )


class RemoteRecorderSortFields(Enum):
    name = 'Name'


class RecorderScheduleEntry(BaseModel):
    id: Optional[str] = Field(None, alias='Id')
    name: Optional[str] = Field(None, alias='Name')
    recorder_id: str = Field(..., alias='RecorderId')
    suppress_primary_capture: bool = Field(..., alias='SuppressPrimaryCapture')
    suppress_secondary_capture: bool = Field(..., alias='SuppressSecondaryCapture')
    recorder_description: Optional[str] = Field(None, alias='RecorderDescription')


class ScheduledRecordingUpdate(BaseModel):
    start_time: Optional[datetime] = Field(
        None,
        alias='StartTime',
        description='The new start time. Times should be UTC. Must be later than the current time',
    )
    end_time: Optional[datetime] = Field(
        None,
        alias='EndTime',
        description='The new end time. Times should be UTC. Must be later than the current time',
    )


class ScheduledRecordingRemoteRecorder(BaseModel):
    remote_recorder_id: str = Field(
        ...,
        alias='RemoteRecorderId',
        description='The id of the remote recorder to use for this recording. Only one can be specified at this time.',
    )
    suppress_primary: bool = Field(
        ...,
        alias='SuppressPrimary',
        description='True if the primary stream should be suppressed from this recorder. At least one recorder in a scheduled recording must not suppress the primary stream.',
    )
    suppress_secondary: bool = Field(
        ...,
        alias='SuppressSecondary',
        description='True if the secondary stream should be suppressed from this recorder.',
    )


class ModelBase(BaseModel):
    id: Optional[str] = Field(
        None, alias='Id', description='The unique identifier for this item.'
    )
    name: Optional[str] = Field(
        None, alias='Name', description='The name of this item.'
    )


class SearchIndexSyncContentResponse(ModelBase):
    pass


class SessionUpdate(BaseModel):
    name: Optional[str] = Field(
        None, alias='Name', description='The new name for the session.'
    )
    description: Optional[str] = Field(
        None, alias='Description', description='The new description for the session.'
    )
    folder: Optional[str] = Field(
        None,
        alias='Folder',
        description='The id of the folder to move this session to.',
    )


class SessionViewerStats(BaseModel):
    user: Optional[User] = Field(None, alias='User')
    percent_completed: Optional[float] = Field(None, alias='PercentCompleted')
    last_viewed_date_time: datetime = Field(..., alias='LastViewedDateTime')
    most_recent_view_position_in_seconds: Optional[float] = Field(
        None,
        alias='MostRecentViewPositionInSeconds',
        description='The most recent timestamp (in seconds) that was viewed by the user in this session',
    )


class Tag(BaseModel):
    id: Optional[str] = Field(None, alias='Id')
    content: Optional[str] = Field(None, alias='Content')
    usage_count: int = Field(..., alias='UsageCount')
    create_date: datetime = Field(..., alias='CreateDate')
    most_recent_use_date: Optional[datetime] = Field(None, alias='MostRecentUseDate')
    created_by: Optional[User] = Field(None, alias='CreatedBy')


class TagSortFields(Enum):
    create_date = 'CreateDate'
    usage_count = 'UsageCount'
    content = 'Content'
    creator = 'Creator'
    most_recent_use_date = 'MostRecentUseDate'


class SessionTagUpdate(BaseModel):
    tags: Optional[List[str]] = Field(
        None, alias='Tags', description='The tags for the session.'
    )


class ContentLanguage(Enum):
    english_usa = 'English_USA'
    english_gbr = 'English_GBR'
    spanish_mex = 'Spanish_MEX'
    spanish_esp = 'Spanish_ESP'
    german = 'German'
    french = 'French'
    dutch = 'Dutch'
    thai = 'Thai'
    chinese_simplified = 'Chinese_Simplified'
    chinese_traditional = 'Chinese_Traditional'
    korean = 'Korean'
    japanese = 'Japanese'
    russian = 'Russian'
    portuguese = 'Portuguese'
    polish = 'Polish'
    english_aus = 'English_AUS'
    danish = 'Danish'
    finnish = 'Finnish'
    hungarian = 'Hungarian'
    norwegian = 'Norwegian'
    swedish = 'Swedish'
    italian = 'Italian'
    welsh = 'Welsh'
    catalan = 'Catalan'
    galician = 'Galician'
    basque = 'Basque'


class ContentLanguage2(Enum):
    english_usa = 'English_USA'
    english_gbr = 'English_GBR'
    spanish_mex = 'Spanish_MEX'
    spanish_esp = 'Spanish_ESP'
    german = 'German'
    french = 'French'
    dutch = 'Dutch'
    thai = 'Thai'
    chinese_simplified = 'Chinese_Simplified'
    chinese_traditional = 'Chinese_Traditional'
    korean = 'Korean'
    japanese = 'Japanese'
    russian = 'Russian'
    portuguese = 'Portuguese'
    polish = 'Polish'
    english_aus = 'English_AUS'
    danish = 'Danish'
    finnish = 'Finnish'
    hungarian = 'Hungarian'
    norwegian = 'Norwegian'
    swedish = 'Swedish'
    italian = 'Italian'
    welsh = 'Welsh'
    catalan = 'Catalan'
    galician = 'Galician'
    basque = 'Basque'


class TagCreate(BaseModel):
    content: Optional[str] = Field(
        None, alias='Content', description='The content of the tag.'
    )


class TagUpdate(TagCreate):
    pass


class TagMerge(BaseModel):
    tag_ids_to_merge: Optional[List[str]] = Field(
        None,
        alias='TagIdsToMerge',
        description='The IDs of the tags that should be merged and then deleted.',
    )


class ListResponseOfUser(BaseModel):
    results: Optional[List[User]] = Field(
        None, alias='Results', description='The list of results from the API call'
    )


class LtiSpecLogin(BaseModel):
    pass


class LtiAgsScore(BaseModel):
    pass


class APIError(BaseModel):
    error: Optional[APIErrorInternal] = Field(None, alias='Error')


class LiveMonitoringHeartbeatResponseData(BaseModel):
    mode: LiveMonitoringMode = Field(..., alias='Mode')
    id: Optional[str] = Field(None, alias='Id')


class RemoteRecorderExtendedConfiguration(BaseModel):
    seconds_to_use_next_recording_template: Optional[float] = Field(
        None,
        alias='SecondsToUseNextRecordingTemplate',
        description="The number of seconds prior to the start of the next scheduled recording to apply the recording's template configurations.",
    )
    seconds_to_delete_recording_after_upload: Optional[float] = Field(
        None,
        alias='SecondsToDeleteRecordingAfterUpload',
        description='The number of seconds to retain the recording on the client after successful upload of the recording',
    )
    server_time: Optional[float] = Field(
        None, alias='ServerTime', description='The server time in UTC file seconds'
    )
    audio_histogram_mode_type: RemoteRecorderAudioHistogramType = Field(
        ..., alias='AudioHistogramModeType'
    )


class Device(BaseModel):
    device_id: Optional[str] = Field(None, alias='DeviceId')
    name: Optional[str] = Field(None, alias='Name')
    type: DeviceType = Field(..., alias='Type')


class RemoteRecorderDevicePreview(BaseModel):
    audio_format: DeviceThumbnailFormat = Field(..., alias='AudioFormat')
    audio_preview_data: Optional[str] = Field(None, alias='AudioPreviewData')
    video_format: DeviceThumbnailFormat = Field(..., alias='VideoFormat')
    video_preview_data: Optional[str] = Field(None, alias='VideoPreviewData')
    stream_id: Optional[str] = Field(None, alias='StreamID')


class RemoteRecorderSchedule(APIError):
    schedule_id: str = Field(..., alias='ScheduleId')
    server_time: float = Field(..., alias='ServerTime')
    recordings: Optional[List[RemoteRecorderScheduledRecording]] = Field(
        None, alias='Recordings'
    )


class RemoteRecorderError(BaseModel):
    severity: RemoteRecorderErrorSeverity = Field(..., alias='Severity')
    error_type: RemoteRecorderErrorType = Field(..., alias='ErrorType')
    error_code: int = Field(
        ..., alias='ErrorCode', description='Vendor-specific error code'
    )
    message: Optional[str] = Field(
        None,
        alias='Message',
        description='Error message with a maximum length of 250 characters',
    )
    associated_session_id: Optional[str] = Field(
        None,
        alias='AssociatedSessionId',
        description='If this error is associated with a session, which session',
    )


class RemoteRecorderURL(BaseModel):
    url_type: RemoteRecorderURLType = Field(..., alias='URLType')
    url: Optional[str] = Field(
        None, alias='URL', description='Must be a well formed URL'
    )


class WebRtcConnectPostData(BaseModel):
    operation_type: WebRtcConnectOperationType = Field(..., alias='OperationType')


class WebRtcDisconnectPostData(BaseModel):
    operation_type: WebRtcDisconnectOperationType = Field(..., alias='OperationType')


class WebRtcEvent(BaseModel):
    event_type: WebRtcEventType = Field(..., alias='EventType')
    payload: Optional[str] = Field(None, alias='Payload')


class WebRtcIceCandidates(BaseModel):
    candidates: Optional[List[WebRtcIceCandidate]] = Field(None, alias='Candidates')


class Folder(BaseModel):
    id: Optional[str] = Field(None, alias='Id')
    name: Optional[str] = Field(None, alias='Name')
    description: Optional[str] = Field(None, alias='Description')
    parent_folder: Optional[BasicFolder] = Field(None, alias='ParentFolder')
    urls: Optional[FolderUrls] = Field(None, alias='Urls')


class ListResponseOfFolder(BaseModel):
    results: Optional[List[Folder]] = Field(
        None, alias='Results', description='The list of results from the API call'
    )


class Session(BaseModel):
    id: Optional[str] = Field(None, alias='Id')
    name: Optional[str] = Field(None, alias='Name')
    description: Optional[str] = Field(None, alias='Description')
    start_time: Optional[datetime] = Field(None, alias='StartTime')
    duration: Optional[float] = Field(
        None, alias='Duration', description='The duration of the session (in seconds)'
    )
    most_recent_view_position: Optional[float] = Field(
        None, alias='MostRecentViewPosition'
    )
    created_by: Optional[User] = Field(None, alias='CreatedBy')
    urls: Optional[SessionUrls] = Field(None, alias='Urls')
    folder: str = Field(..., alias='Folder')
    folder_details: Optional[BasicFolder] = Field(None, alias='FolderDetails')
    context: Optional[List[SearchResultContext]] = Field(None, alias='Context')
    percent_completed: Optional[int] = Field(
        None,
        alias='PercentCompleted',
        description='The percentage from 0-100 of the session watched by the requested user',
    )


class Playlist(ModelBaseOfGuid):
    description: Optional[str] = Field(None, alias='Description')
    folder: Optional[BasicFolder] = Field(None, alias='Folder')
    urls: Optional[PlaylistUrls] = Field(None, alias='Urls')


class AccessSettings(BaseModel):
    is_inherited: bool = Field(
        ...,
        alias='IsInherited',
        description='Indicates whether or not the access settings are inherited.',
    )
    level: AccessLevel = Field(..., alias='Level')


class Principal(BaseModel):
    id: Optional[str] = Field(
        None, alias='Id', description='The unique id that represents this principal.'
    )
    type: PrincipalType = Field(..., alias='Type')


class PermissionCreate(BaseModel):
    role_id: Optional[str] = Field(
        None,
        alias='RoleId',
        description='Id of the role to assign to the user or group. Required when RoleType is null or None.',
    )
    role_type: Optional[BuiltInRoleType] = Field(None, alias='RoleType')
    principal_id: str = Field(
        ...,
        alias='PrincipalId',
        description='Id of the user or group to which the role is being assigned.',
    )
    principal_type: PrincipalType = Field(..., alias='PrincipalType')


class ListResponseOfGroup(BaseModel):
    results: Optional[List[Group]] = Field(
        None, alias='Results', description='The list of results from the API call'
    )


class ListResponseOfRemoteRecorder(BaseModel):
    results: Optional[List[RemoteRecorder]] = Field(
        None, alias='Results', description='The list of results from the API call'
    )


class ScheduledRecording(BaseModel):
    id: Optional[str] = Field(None, alias='Id')
    name: Optional[str] = Field(None, alias='Name')
    recorder_schedule_entries: Optional[List[RecorderScheduleEntry]] = Field(
        None,
        alias='RecorderScheduleEntries',
        description='A list of recorders and their associated properties',
    )
    start_time: Optional[datetime] = Field(
        None, alias='StartTime', description='The start time for the recording'
    )
    end_time: Optional[datetime] = Field(
        None, alias='EndTime', description='The end time for the recording'
    )


class ScheduledRecordingCreate(BaseModel):
    name: Optional[str] = Field(
        None, alias='Name', description='The name of the scheduled recording.'
    )
    description: Optional[str] = Field(
        None,
        alias='Description',
        description='An optional description for the scheduled recording.',
    )
    start_time: datetime = Field(
        ...,
        alias='StartTime',
        description='The date and time the scheduled recording should start.',
    )
    end_time: datetime = Field(
        ...,
        alias='EndTime',
        description='The date and time the scheduled recording should end.',
    )
    folder_id: str = Field(
        ...,
        alias='FolderId',
        description='The folder to add this scheduled recording to.',
    )
    recorders: Optional[List[ScheduledRecordingRemoteRecorder]] = Field(
        None,
        alias='Recorders',
        description='A list of recorders that will be used for this recording',
    )
    is_broadcast: bool = Field(
        ...,
        alias='IsBroadcast',
        description='Set to true if this recording should be broadcast live when it starts.',
    )


class SearchIndexSyncUpdateResponse(ModelBase):
    pass


class ListResponseOfSessionViewerStats(BaseModel):
    results: Optional[List[SessionViewerStats]] = Field(
        None, alias='Results', description='The list of results from the API call'
    )


class ListResponseOfTag(BaseModel):
    results: Optional[List[Tag]] = Field(
        None, alias='Results', description='The list of results from the API call'
    )


class RemoteRecorderRegistrationResponse(APIError):
    remote_recorder_public_id: str = Field(..., alias='RemoteRecorderPublicId')
    client_key: str = Field(..., alias='ClientKey')
    client_secret: Optional[str] = Field(None, alias='ClientSecret')


class RemoteRecorderHeartbeatResponse(APIError):
    schedule_version: str = Field(..., alias='ScheduleVersion')
    settings_version: str = Field(..., alias='SettingsVersion')
    ping_interval: int = Field(..., alias='PingInterval')
    configuration: Optional[RemoteRecorderConfiguration] = Field(
        None, alias='Configuration'
    )
    recording_session_is_paused: Optional[bool] = Field(
        None,
        alias='RecordingSessionIsPaused',
        description='Indicates whether the current recording (as per CurrentRecordingSessionId) is in a paused state. This parameter will not be emitted if no CurrentRecordingSessionId is provided.',
    )
    live_monitoring: Optional[LiveMonitoringHeartbeatResponseData] = Field(
        None, alias='LiveMonitoring'
    )
    default_folder: Optional[str] = Field(None, alias='DefaultFolder')
    default_primary_quality_settings: Optional[QualitySettings] = Field(
        None, alias='DefaultPrimaryQualitySettings'
    )
    default_secondary_quality_settings: Optional[QualitySettings] = Field(
        None, alias='DefaultSecondaryQualitySettings'
    )
    extended_configuration: Optional[RemoteRecorderExtendedConfiguration] = Field(
        None, alias='ExtendedConfiguration'
    )


class DeviceDescriptionWithPreview(BaseModel):
    device: Optional[Device] = Field(None, alias='Device')
    preview: Optional[RemoteRecorderDevicePreview] = Field(None, alias='Preview')


class RemoteRecorderURLsUpdateRequest(BaseModel):
    ur_ls: Optional[List[RemoteRecorderURL]] = Field(None, alias='URLs')


class WebRtcEventsResponse(APIError):
    events: Optional[List[WebRtcEvent]] = Field(None, alias='Events')
    ping_fast_interval: int = Field(..., alias='PingFastInterval')
    ping_slow_interval: int = Field(..., alias='PingSlowInterval')


class ListResponseOfSession(BaseModel):
    results: Optional[List[Session]] = Field(
        None, alias='Results', description='The list of results from the API call'
    )


class ListResponseOfPlaylist(BaseModel):
    results: Optional[List[Playlist]] = Field(
        None, alias='Results', description='The list of results from the API call'
    )


class Permission(BaseModel):
    is_inherited: bool = Field(
        ...,
        alias='IsInherited',
        description='Indicates whether or not the permission is inherited.',
    )
    principal: Optional[Principal] = Field(None, alias='Principal')
    role: Optional[Role] = Field(None, alias='Role')


class RemoteRecorderHeartbeatData(BaseModel):
    state: RemoteRecorderState = Field(..., alias='State')
    disk_space_free_megabytes: int = Field(..., alias='DiskSpaceFreeMegabytes')
    current_recording_session_id: Optional[str] = Field(
        None, alias='CurrentRecordingSessionId'
    )
    connected_devices_with_previews: Optional[List[DeviceDescriptionWithPreview]] = (
        Field(
            None,
            alias='ConnectedDevicesWithPreviews',
            description='List of connected devices and available previews. If excluded or null, the list of connected devices will not be updated.',
        )
    )
    live_monitoring_blocked: bool = Field(
        ...,
        alias='LiveMonitoringBlocked',
        description='If supported, whether or not live audio monitoring is currently blocked.',
    )


class ListResponseOfPermission(BaseModel):
    results: Optional[List[Permission]] = Field(
        None, alias='Results', description='The list of results from the API call'
    )
